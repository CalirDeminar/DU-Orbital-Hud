name: ButtonsHud - Dimencia and Archaegeo v4.58

slots:
    core:
        class: CoreUnit
    radar:
        class: RadarPVPUnit
        select: manual
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    dbHud:
        class: databank
    vBooster:
        class: VerticalBooster
    hover:
        class: Hovercraft
    door:
        class: DoorUnit
        select: manual
    forcefield:
        class: ForceFieldUnit
        select: manual
    atmofueltank:
        class: AtmoFuelContainer
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: manual
    rocketfueltank:
        class: RocketFuelContainer
        select: manual

handlers:
    unit:
        start:
            lua: "SetupComplete = false\nbeginSetup = coroutine.create(function() \nNav
        = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,
        {1000, 5000, 10000, 20000, 30000})\n-- Written by Dimencia.  Linked sources
        where appropriate, most have been modified.  HUD by Archeageo\nversionNumber
        = 4.58\n-- function localizations\nlocal mfloor = math.floor\nlocal stringf
        = string.format\nlocal jdecode = json.decode\nlocal jencode = json.encode\nlocal
        eleMaxHp = core.getElementMaxHitPointsById\nlocal atmosphere = unit.getAtmosphereDensity\nlocal
        eleHp = core.getElementHitPointsById\nlocal eleType = core.getElementTypeById\nlocal
        eleMass = core.getElementMassById\nlocal constructMass = core.getConstructMass\nlocal
        isRemote = Nav.control.isRemoteControlled\n-- USER DEFINABLE GLOBAL AND LOCAL
        VARIABLES THAT SAVE\nAutopilotTargetOrbit = 100000 --export: How far you want
        the orbit to be from the planet in m.  200,000 = 1SU\nwarmup = 32 --export:
        How long it takes your engines to warmup.  Basic Space Engines, from XS to
        XL: 0.25,1,4,16,32\nPrimaryR = 130 --export: Primary HUD color\nPrimaryG =
        224 --export: Primary HUD color\nPrimaryB = 255 --export: Primary HUD color\nuserControlScheme
        = \"Keyboard\" --export: Set to \"Virtual Joystick\", \"Mouse\", or
        \"Keyboard\"\nfreeLookToggle = true --export: Set to false for default free
        look behavior.\napTickRate = 0.0166667 --export: Set the Tick Rate for your
        HUD.  0.016667 is effectively 60 fps and the default value. 0.03333333 is
        30 fps.  The bigger the number the less often the autopilot and hud updates
        but may help peformance on slower machings.\nMaxGameVelocity = 8333.05 --export:
        Max speed for your autopilot in m/s, do not go above 8333.055 (30000 km/hr),
        use 6944.4444 for 25000km/hr\nAutoTakeoffAltitude = 1000 --export: How high
        above your starting position AutoTakeoff tries to put you\nDeadZone = 50 --export:
        Number of pixels of deadzone at the center of the screen\nMouseYSensitivity
        = 0.003 --export:1 For virtual joystick only\nMouseXSensitivity = 0.003 --export:
        For virtual joystick only\ncircleRad = 99 --export: The size of the artifical
        horizon circle, set to 0 to remove.\nautoRollPreference = false --export:
        [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try
        to get back to horizontal (no roll)\nshowHud = true --export: Uncheck to hide
        the HUD and only use autopilot features via ALT+# keys.\nhideHudOnToggleWidgets
        = true --export: Uncheck to keep showing HUD when you toggle on the widgets
        via ALT+3.\nfuelTankOptimizationAtmo = 0 --export: For accurate estimates,
        set this to the fuel tank optimization level of the person who placed the
        element. Ignored for slotted tanks.\nfuelTankOptimizationSpace = 0 --export:
        For accurate estimates, set this to the fuel tank optimization level of the
        person who placed the element. Ignored for slotted tanks.\nfuelTankOptimizationRocket
        = 0 --export: For accurate estimates, set this to the fuel tank optimization
        level of the person who placed the element. Ignored for slotted tanks.\nRemoteFreeze
        = false --export: Whether or not to freeze you when using a remote controller.
        \ Breaks some things, only freeze on surfboards\npitchSpeedFactor = 0.8 --export:
        For keyboard control\nyawSpeedFactor =  1 --export: For keyboard control\nrollSpeedFactor
        = 1.5 --export: This factor will increase/decrease the player input along
        the roll axis<br>(higher value may be unstable)<br>Valid values: Superior
        or equal to 0.01\nbrakeSpeedFactor = 3 --export: When braking, this factor
        will increase the brake force by brakeSpeedFactor * velocity<br>Valid values:
        Superior or equal to 0.01\nbrakeFlatFactor = 1 --export: When braking, this
        factor will increase the brake force by a flat brakeFlatFactor * velocity
        direction><br>(higher value may be unstable)<br>Valid values: Superior or
        equal to 0.01\nautoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll
        is engaged, this factor will increase to strength of the roll back to 0<br>Valid
        values: Superior or equal to 0.01\nturnAssist = false --export: [Only in atmosphere]<br>When
        the pilot is rolling, the flight model will try to add yaw and pitch to make
        the construct turn better<br>The flight model will start by adding more yaw
        the more horizontal the construct is and more pitch the more vertical it is\nturnAssistFactor
        = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the
        turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior
        or equal to 0.01\nTargetHoverHeight = 50 --export: Hover height when retracting
        landing gear\nAutopilotInterplanetaryThrottle = 100 --export: How much throttle,
        in percent, you want it to use when autopiloting to another planet\nShiftShowsRemoteButtons
        = true --export: Whether or not pressing Shift in remote controller mode shows
        you the buttons (otherwise no access to them)\nDampingMultiplier = 40 --export:
        How strongly autopilot dampens when nearing the correct orientation\nspeedChangeLarge
        = 5 --export: The speed change that occurs when you tap speed up/down, default
        is 5 (25% throttle change). \nspeedChangeSmall = 1 --export: the speed change
        that occurs while you hold speed up/down, default is 1 (5% throttle change).\nbrightHud
        = false --export: Enable to prevent hud dimming when in freelook.\nbrakeLandingRate
        = 30 --export: Max loss of altitude speed in m/s when doing a brake landing,
        default 30.  This is to prevent \"bouncing\" as hover/boosters catch you.
        \ Do not use negative number.\nMaxPitch = 20 --export: Maximum allowed pitch
        during takeoff and altitude changes while in altitude hold.  Default is 20
        deg.  You can set higher or lower depending on your ships capabilities.\nReentrySpeed
        = 1050 --export: Target re-entry speed once in atmosphere in m/s.  291 = 1050
        km/hr, higher might cause reentry burn.\nReentryAltitude = 2500 --export:
        Target alititude when using re-entry.\nEmergencyWarpDistance = 320000 --export:
        Set to distance as which an emergency warp will occur if radar target within
        that distance.  320000 is lock range for large radar on large ship no special
        skills.\n-- GLOBAL VARIABLES SECTION, IF NOT USED OUTSIDE UNIT.START, MAKE
        IT LOCAL\nmarkers = {}\nMinAutopilotSpeed = 55 -- Minimum speed for autopilot
        to maneuver in m/s.  Keep above 25m/s to prevent nosedives when boosters kick
        in\nLastMaxBrake = 0\nEmergencyWarp = false\nReentryMode = false\nbrakeToggle
        = true \ndisplayOrbit = true \nmousePitchFactor = 1 -- Mouse control only\nmouseYawFactor
        = 1 -- Mouse control only\nhasGear = false\npitchInput = 0\nrollInput = 0\nyawInput
        = 0\nbrakeInput = 0\npitchInput2 = 0\nrollInput2 = 0\nyawInput2 = 0\nBrakeIsOn
        = false\nRetrogradeIsOn = false             \nProgradeIsOn = false             \nAutoBrake
        = false\nReentry = false\nAutopilot = false\nFollowMode = false\nTurnBurn
        = false\nAltitudeHold = false\nBrakeLanding = false\nAutoTakeoff = false\nHoldAltitude
        = 1000 -- In case something goes wrong, give this a decent start value\nAutopilotAccelerating
        = false\nAutopilotBraking = false\nAutopilotCruising = false \nAutopilotRealigned
        = false\nVectorToTarget = false\nAutopilotEndSpeed = 0\nAutopilotStatus =
        \"Aligning\"\nsimulatedX = 0\nsimulatedY = 0\nHoldingCtrl = false\nPrevViewLock
        = 1\nPreviousYawAmount = 0\nPreviousPitchAmount = 0\nmsgText = \"empty\"\nmsgTimer
        = 3\ntargetGroundAltitude = nil -- So it can tell if one loaded or not\ngearExtended
        = nil\nLastEccentricity = 1\nHoldAltitudeButtonModifier = 5\nisBoosting =
        false -- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition\ndistance
        = 0\nbrakeDistance, brakeTime = 0\nmaxBrakeDistance, maxBrakeTime = 0\nhasGear
        = false\nhasDB = false\nhasSpaceRadar = false\nhasAtmoRadar = false\ndamageMessage
        = \"\"\nradarMessage = \"\"\nLastOdometerOutput = \"\"\nperis = 0\nAutopilotTargetIndex
        = 0\nAutopilotTargetName = \"None\"\nAutopilotTargetPlanet = nil\nAutopilotPlanetGravity
        = 0\nUnitHidden = true\nResetAutoVars = false\ntotalDistanceTravelled = 0.0\ntotalDistanceTrip
        = 0\nemergencyWarp = false\nnotTriedEmergencyWarp = true\nlastTravelTime =
        system.getTime()\ncore_altitude = core.getAltitude()\nelementsID = core.getElementIdList()
        \n-- Do not save these, they contain elementID's which can change.\natmoTanks
        = {}\nspaceTanks = {}\nrocketTanks = {}\neleTotalMaxHp = 0\nflightTime = 0\ntotalFlightTime
        = 0\nRepairArrows = false\n-- updateHud() variables\nfuelTimeLeftR = {}\nfuelPercentR
        = {}\nFuelUpdateDelay = mfloor(1/apTickRate)*2\nfuelTimeLeftS = {}\nfuelPercentS
        = {}\nfuelTimeLeft = {}\nfuelPercent = {}\nSavedLocations = {}\nLocationIndex
        = 0\nupdateTanks = false\nhoneyCombMass = 0\nupAmount = 0\n-- LOCAL VARIABLES,
        USERS DO NOT CHANGE\nlocal Buttons = {}\nlocal AutopilotStrength = 1 -- How
        strongly autopilot tries to point at a target\nlocal alignmentTolerance =
        0.001 -- How closely it must align to a planet before accelerating to it\nlocal
        ResolutionWidth = 2560\nlocal ResolutionHeight = 1440\nlocal minAtlasX = nil\nlocal
        maxAtlasX = nil\nlocal minAtlasY = nil\nlocal maxAtlasY = nil\nlocal valuesAreSet
        = false\nlocal doubleCheck = false\nlocal totalMass = 0\nlocal lastMaxBrakeAtG
        = nil\n-- VARIABLES TO BE SAVED GO HERE\nSaveableVariables = \n{\n\"userControlScheme\",
        \n\"AutopilotTargetOrbit\",\n\"apTickRate\",\n\"freeLookToggle\",\n\"turnAssist\",\n\"PrimaryR\",\n\"PrimaryG\",\n\"PrimaryB\",\n\"warmup\",\n\"DeadZone\",\n\"circleRad\",\n\"MouseXSensitivity\",\n\"MouseYSensitivity\",\n\"MaxGameVelocity\",\n\"showHud\",\n\"autoRollPreference\",\n\"pitchSpeedFactor\",\n\"yawSpeedFactor\",\n\"rollSpeedFactor\",\n\"brakeSpeedFactor\",\n\"brakeFlatFactor\",\n\"autoRollFactor\",\n\"turnAssistFactor\",\n\"torqueFactor\",\n\"AutoTakeoffAltitude\",\n\"TargetHoverHeight\",\n\"AutopilotInterplanetaryThrottle\",\n\"hideHudOnToggleWidgets\",\n\"DampingMultiplier\",\n\"fuelTankOptimizationAtmo\",\n\"fuelTankOptimizationSpace\",\n\"fuelTankOptimizationRocket\",\n\"RemoteFreeze\",\n\"speedChangeLarge\",\n\"speedChangeSmall\",\n\"brightHud\",\n\"brakeLandingRate\",\n\"MaxPitch\",\n\"ReentrySpeed\",\n\"ReentryAltitude\",\n\"EmergencyWarpDistance\"\n}\nAutoVariables
        = \n{\n\"EmergencyWarp\",\n\"hasGear\",\n\"brakeToggle\",\n\"BrakeIsOn\",\n\"RetrogradeIsOn\",
        \            \n\"ProgradeIsOn\",             \n\"AutoBrake\",\n\"Autopilot\",\n\"TurnBurn\",\n\"AltitudeHold\",\n\"displayOrbit\",\n\"BrakeLanding\",\n\"Reentry\",\n\"AutoTakeoff\",\n\"HoldAltitude\",\n\"AutopilotAccelerating\",\n\"AutopilotBraking\",\n\"AutopilotCruising\",
        \n\"AutopilotRealigned\",\n\"AutopilotEndSpeed\",\n\"AutopilotStatus\",\n\"AutopilotPlanetGravity\",\n\"PrevViewLock\",\n\"AutopilotTargetName\",\n\"AutopilotTargetCoords\",\n\"AutopilotTargetIndex\",\n\"gearExtended\",\n\"targetGroundAltitude\",\n\"totalDistanceTravelled\",\n\"totalFlightTime\",\n\"SavedLocations\",\n\"VectorToTarget\",\n\"LocationIndex\",\n\"LastMaxBrake\"\n}\n--
        BEGIN CONDITIONAL CHECKS DURING STARTUP\n-- Load Saved Variables\nif dbHud
        then\nlocal hasKey = dbHud.hasKey\nfor k,v in pairs(SaveableVariables) do\nif
        hasKey(v) then\nlocal result = jdecode(dbHud.getStringValue(v))\nif result
        ~= nil then\nsystem.print(v..\" \"..dbHud.getStringValue(v))\n_G[v] = result\nvaluesAreSet
        = true\nend\nend\nend\nfor k,v in pairs(AutoVariables) do\nif hasKey(v) then\nlocal
        result = jdecode(dbHud.getStringValue(v))\nif result ~= nil then\nsystem.print(v..\"
        \"..dbHud.getStringValue(v))\n_G[v] = result\nend\nend\nend\nif valuesAreSet
        then\nmsgText = \"Loaded Saved Variables (see Lua Chat Tab for list)\"\nautoRoll
        = autoRollPreference\nelse\nmsgText = \"No Saved Variables Found - Use Alt-7
        to save your LUA parameters\"\nend\nelse\nmsgText = \"No databank found\"\nend\n--
        Loading saved vars is hard on it\nlastConstructMass = constructMass()\nhoneyCombMass
        = lastConstructMass - updateMass()\nrgb = [[rgb(]] .. mfloor(PrimaryR+0.5)
        .. \",\" .. mfloor(PrimaryG+0.5) .. \",\" .. mfloor(PrimaryB+0.5) .. [[)]]\nrgbdim
        = [[rgb(]] .. mfloor(PrimaryR *0.9 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.9
        + 0.5) .. \",\" .. mfloor(PrimaryB * 0.9 + 0.5) .. [[)]]\nUpdateCount = 0\ntitlecolR
        = rgb\ntitlecol = rgb\ntitlecolS = rgb\ncoroutine.yield() -- Give it some
        time to breathe before we do the rest\nfor k in pairs(elementsID) do\nlocal
        name = eleType(elementsID[k])\nif (name == \"landing gear\") then \nhasGear
        = true\nend\nif (name == \"dynamic core\") then\nlocal hp = eleMaxHp(elementsID[k])\ncoreOffset
        = 16\nif hp > 10000 then \ncoreOffset = 128\nelseif hp > 1000 then\ncoreOffset
        = 64\nelseif hp > 150 then\ncoreOffset = 32\nend\nend\neleTotalMaxHp = eleTotalMaxHp
        + eleMaxHp(elementsID[k])\nif (name == \"atmospheric fuel-tank\" or name ==
        \"space fuel-tank\" or name == \"rocket fuel-tank\" ) then\nlocal hp = eleMaxHp(elementsID[k])\nlocal
        mass = eleMass(elementsID[k])\nlocal curMass = 0\nlocal curTime = system.getTime()\nif
        (name == \"atmospheric fuel-tank\") then \nlocal vanillaMaxVolume = 400\nlocal
        massEmpty = 35.03\nif hp > 10000 then \nvanillaMaxVolume = 51200 -- volume
        in kg of L tank\nmassEmpty = 5480\nelseif hp > 1300 then\nvanillaMaxVolume
        =  6400 -- volume in kg of M\nmassEmpty = 988.67\nelseif hp > 150 then\nvanillaMaxVolume
        = 1600 --- volume in kg small\nmassEmpty = 182.67\nend\ncurMass = mass - massEmpty\nif
        fuelTankOptimizationAtmo > 0 then \nvanillaMaxVolume = vanillaMaxVolume +
        (vanillaMaxVolume*(fuelTankOptimizationAtmo*0.2))\nend\nif curMass > vanillaMaxVolume
        then \nvanillaMaxVolume = curMass\nend\natmoTanks[#atmoTanks + 1] = {elementsID[k],
        core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass,
        curTime}\nend\nif (name == \"rocket fuel-tank\") then \nlocal vanillaMaxVolume
        = 320\nlocal massEmpty = 173.42\nif hp > 65000 then \nvanillaMaxVolume = 40000
        -- volume in kg of L tank\nmassEmpty = 25740\nelseif hp > 6000 then\nvanillaMaxVolume
        =  5120 -- volume in kg of M\nmassEmpty = 4720\nelseif hp > 700 then\nvanillaMaxVolume
        = 640 --- volume in kg small\nmassEmpty = 886.72\nend\ncurMass = mass - massEmpty\nif
        fuelTankOptimizationRocket > 0 then \nvanillaMaxVolume = vanillaMaxVolume
        + (vanillaMaxVolume*(fuelTankOptimizationRocket*0.1))\nend\nif curMass > vanillaMaxVolume
        then \nvanillaMaxVolume = curMass\nend\nrocketTanks[#rocketTanks + 1] = {elementsID[k],
        core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass,
        curTime}\nend\nif (name == \"space fuel-tank\") then \nlocal vanillaMaxVolume
        = 2400\nlocal massEmpty = 182.67\nif hp > 10000 then \nvanillaMaxVolume =
        76800 -- volume in kg of L tank\nmassEmpty = 5480\nelseif hp > 1300 then\nvanillaMaxVolume
        =  9600 -- volume in kg of M\nmassEmpty = 988.67\nend\ncurMass = mass - massEmpty\nif
        fuelTankOptimizationSpace > 0 then \nvanillaMaxVolume = vanillaMaxVolume +
        (vanillaMaxVolume*(fuelTankOptimizationSpace*0.2))\nend\nif curMass > vanillaMaxVolume
        then \nvanillaMaxVolume = curMass\nend\nspaceTanks[#spaceTanks + 1] = {elementsID[k],
        core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass,
        curTime}\nend\nend\nend\nif gyro ~= nil then\nGyroIsOn = gyro.getState() ==
        1\nend\nif userControlScheme ~= \"Keyboard\" then\nsystem.lockView(1)\nelse\nsystem.lockView(0)\nend\nif
        atmosphere() > 0 then\nBrakeIsOn = true\nend  \nif radar_1 then\nif eleType(radar_1.getId())
        == \"Space Radar\" then\nhasSpaceRadar = true\nelse\nhasAtmoRadar = true\nend\nend\n--
        Close door and retract ramp if available\nif door then\nfor _,v in pairs(door)
        do\nv.deactivate()\nend\nend\nif forcefield then\nfor _,v in pairs(forcefield)
        do\nv.deactivate()\nend\nend\n_autoconf.displayCategoryPanel(weapon, weapon_size,
        L_TEXT(\"ui_lua_widget_weapon\", \"Weapons\"), \"weapon\", true)\nif antigrav
        ~= nil then antigrav.show() end\n-- unfreeze the player if he is remote controlling
        the construct\nif isRemote() == 1 and RemoteFreeze then\nsystem.freeze(1)\nelse\nsystem.freeze(0)\nend\nif
        targetGroundAltitude ~= nil then\nNav.axisCommandManager:setTargetGroundAltitude(targetGroundAltitude)\nend\nif
        hasGear then\nif gearExtended == nil then\ngearExtended = (Nav.control.isAnyLandingGearExtended()
        == 1) -- make sure it's a lua boolean\nif gearExtended then\nNav.control.extendLandingGears()\nelse\nNav.control.retractLandingGears()\nend\nend\nif
        targetGroundAltitude == nil then\nif gearExtended then\nNav.axisCommandManager:setTargetGroundAltitude(0)\nelse\nNav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)\nend\nend\nelseif
        targetGroundAltitude == nil then\nif atmosphere() == 0 then\ngearExtended
        = false\nNav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)\nelse\ngearExtended
        = true -- Show warning message and set behavior\nNav.axisCommandManager:setTargetGroundAltitude(0)\nend\nend\nif
        atmosphere() > 0 and not dbHud and (gearExtended or not hasGear) then\nBrakeIsOn
        = true\nend\nunit.hide()\n-- BEGIN FUNCTION DEFINITIONS\nfunction refreshLastMaxBrake(gravity,
        force)\nif gravity == nil then gravity = core.g() end\ngravity = round(gravity,
        5) -- round to avoid insignificant updates\nif (force ~= nil and force) or
        (lastMaxBrakeAtG == nil or lastMaxBrakeAtG ~= gravity) then\nlocal maxBrake
        = jdecode(unit.getData()).maxBrake\nif maxBrake ~= nil then LastMaxBrake =
        maxBrake end\nlastMaxBrakeAtG = gravity\nend\nend\nfunction MakeButton(enableName,
        disableName, width, height, x, y, toggleVar, toggleFunction, drawCondition)\nlocal
        newButton = { enableName = enableName, disableName = disableName, width=width,height=height,
        x=x, y=y, toggleVar = toggleVar, toggleFunction=toggleFunction, drawCondition=drawCondition,
        hovered=false }\ntable.insert(Buttons, newButton)\nreturn newButton -- readonly,
        I don't think it will be saved if we change these?  Maybe.\nend\nfunction
        AddLocationsToAtlas() -- Just called once during init really\nfor k,v in pairs(SavedLocations)
        do\ntable.insert(atlas[0],v)\nend\nend\nfunction AddNewLocation() -- Don't
        call this unless they have a databank or it's kinda pointless\n-- Add a new
        location to SavedLocations\nif dbHud then\nlocal position = vec3(core.getConstructWorldPos())\nlocal
        name = #SavedLocations .. \". \" .. planet.name -- TODO: If radar isn't jammed,
        get the name of the nearest construct and tack it on here\nif radar_1 then
        -- Just match the first one\nlocal id,distance = radar_1.getData():match('\"constructId\":\"([0-9]*)\",\"distance\":([%d%.]*)')\nif
        id ~= nil and id ~= \"\" then\nname = name .. \" \" .. radar_1.getConstructName(id)\nend\nend\nlocal
        newLocation = { position=position, name=name, atmosphere=unit.getAtmosphereDensity(),
        planetname=planet.name, gravity=unit.getClosestPlanetInfluence()} \nSavedLocations[#SavedLocations
        + 1] = newLocation\n-- Nearest planet, gravity also important - if it's 0,
        we don't autopilot to the target planet, the target isn't near a planet.                      \ntable.insert(atlas[0],
        newLocation)\n-- Store atmosphere so we know whether the location is in space
        or not\nmsgText = \"Location saved as \" .. name\nelse\nmsgText = \"Databank
        must be installed to save locations\"\nend\nend\nfunction ClearCurrentPosition()\n--
        So AutopilotTargetIndex is special and not a real index.  We have to do this
        by hand.\nlocal index = -1\nfor k,v in pairs(atlas[0]) do\nif v.name and v.name
        == CustomTarget.name then\nindex = k\nend\nend\nif index > -1 then\ntable.remove(atlas[0],index)\nend\n--
        And SavedLocations\nindex = -1\nfor k,v in pairs(SavedLocations) do\nif v.name
        and v.name == CustomTarget.name then\nmsgText = v.name..\" saved location
        cleared\"\nindex = k\nbreak\nend\nend\nif index ~= -1 then\ntable.remove(SavedLocations,index)\nend\nDecrementAutopilotTargetIndex()\nend\nfunction
        DrawDeadZone(newContent)\nnewContent[#newContent + 1] = stringf([[<circle
        class=\"dim line\" style=\"fill:none\" cx=\"50%%\" cy=\"50%%\" r=\"%d\"/>]],DeadZone)\nend\nfunction
        ToggleRadarPanel()\nif radarPanelID ~= nil and peris == 0 then\nsystem.destroyWidgetPanel(radarPanelID)\nradarPanelID
        = nil\nif perisPanelID ~= nil then\nsystem.destroyWidgetPanel(perisPanelID)\nperisPanelID
        = nil\nend\nelse\n-- If radar is installed but no weapon, don't show periscope\nif
        peris == 1 then\nsystem.destroyWidgetPanel(radarPanelID)\nradarPanelID = nil\n_autoconf.displayCategoryPanel(radar,
        radar_size, L_TEXT(\"ui_lua_widget_periscope\", \"Periscope\"), \"periscope\")\nperisPanelID
        =  _autoconf.panels[_autoconf.panels_size]\nend\nplaceRadar = true\nif radarPanelID
        == nil and placeRadar then\n_autoconf.displayCategoryPanel(radar, radar_size,
        L_TEXT(\"ui_lua_widget_radar\", \"Radar\"), \"radar\")\nradarPanelID =  _autoconf.panels[_autoconf.panels_size]\nplaceRadar
        = false\nend\nperis = 0\nend\nend\nfunction ToggleWidgets()\nif UnitHidden
        then\nunit.show()\ncore.show()\nif atmofueltank_size > 0 then\n_autoconf.displayCategoryPanel(atmofueltank,
        atmofueltank_size, L_TEXT(\"ui_lua_widget_atmofuel\", \"Atmo Fuel\"), \"fuel_container\")\nfuelPanelID
        =  _autoconf.panels[_autoconf.panels_size]\nend\nif spacefueltank_size > 0
        then\n_autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT(\"ui_lua_widget_spacefuel\",
        \"Space Fuel\"), \"fuel_container\")\nspacefuelPanelID =  _autoconf.panels[_autoconf.panels_size]\nend\nif
        rocketfueltank_size > 0 then\n_autoconf.displayCategoryPanel(rocketfueltank,
        rocketfueltank_size, L_TEXT(\"ui_lua_widget_rocketfuel\", \"Rocket Fuel\"),
        \"fuel_container\")\nrocketfuelPanelID =  _autoconf.panels[_autoconf.panels_size]\nend\nUnitHidden
        = false\nelse\nunit.hide()\ncore.hide()\nif fuelPanelID ~= nil then\nsystem.destroyWidgetPanel(fuelPanelID)\nfuelPanelID
        = nil\nend\nif spacefuelPanelID ~= nil then\nsystem.destroyWidgetPanel(spacefuelPanelID)\nspacefuelPanelID
        = nil\nend\nif rocketfuelPanelID ~= nil then\nsystem.destroyWidgetPanel(rocketfuelPanelID)\nrocketfuelPanelID
        = nil\nend\nUnitHidden = true\nend\nend\n-- Interplanetary helper\nfunction
        SetupInterplanetaryPanel()\npanelInterplanetary = system.createWidgetPanel(\"Interplanetary
        Helper\")\ninterplanetaryHeader = system.createWidget(panelInterplanetary,
        \"value\")\ninterplanetaryHeaderText = system.createData('{\"label\": \"Target
        Planet\", \"value\": \"N/A\", \"unit\":\"\"}')\nsystem.addDataToWidget(interplanetaryHeaderText,
        interplanetaryHeader)\nwidgetDistance = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetDistanceText = system.createData('{\"label\": \"Distance\",
        \"value\": \"N/A\", \"unit\":\"\"}')\nsystem.addDataToWidget(widgetDistanceText,
        widgetDistance)\nwidgetTravelTime = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetTravelTimeText = system.createData('{\"label\": \"Travel
        Time\", \"value\": \"N/A\", \"unit\":\"\"}')\nsystem.addDataToWidget(widgetTravelTimeText,
        widgetTravelTime)\nwidgetMaxMass = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetMaxMassText = system.createData('{\"label\": \"Maximum Mass\",
        \"value\": \"N/A\", \"unit\":\"\"}')\nsystem.addDataToWidget(widgetMaxMassText,
        widgetMaxMass)\nwidgetCurBrakeDistance = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetCurBrakeDistanceText = system.createData('{\"label\": \"Cur
        Brake Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\nif not InAtmo then
        system.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)
        end\nwidgetCurBrakeTime = system.createWidget(panelInterplanetary, \"value\")\nwidgetCurBrakeTimeText
        = system.createData('{\"label\": \"Cur Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\nif
        not InAtmo then system.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)
        end\nwidgetMaxBrakeDistance = system.createWidget(panelInterplanetary, \"value\")\nwidgetMaxBrakeDistanceText
        = system.createData('{\"label\": \"Max Brake Distance\", \"value\": \"N/A\",
        \"unit\":\"\"}')\nif not InAtmo then system.addDataToWidget(widgetMaxBrakeDistanceText,
        widgetMaxBrakeDistance) end\nwidgetMaxBrakeTime = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetMaxBrakeTimeText = system.createData('{\"label\": \"Max
        Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\nif not InAtmo then system.addDataToWidget(widgetMaxBrakeTimeText,
        widgetMaxBrakeTime) end\nwidgetTrajectoryAltitude = system.createWidget(panelInterplanetary,
        \"value\")\nwidgetTrajectoryAltitudeText = system.createData('{\"label\":
        \"Projected Altitude\", \"value\": \"N/A\", \"unit\":\"\"}')\nif not InAtmo
        then system.addDataToWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)
        end\nend\nfunction Contains(mousex, mousey, x, y, width, height) \nif mousex
        > x and mousex < (x + width) and mousey > y and mousey < (y + height) then\nreturn
        true\nelse\nreturn false\nend\nend\nfunction ToggleTurnBurn()\nTurnBurn =
        not TurnBurn\nend\nfunction ToggleVectorToTarget()\n-- This is a feature to
        vector toward the target destination in atmo or otherwise on-planet\n-- Uses
        altitude hold.  \nVectorToTarget = not VectorToTarget\nif VectorToTarget then\nTurnBurn
        = false\nif not AltitudeHold then\nToggleAltitudeHold()\nend\nend\nVectorStatus
        = \"Proceeding to Waypoint\"\nend\nfunction ToggleAutoLanding()\nif BrakeLanding
        then\nBrakeLanding = false\n-- Don't disable alt hold for auto land\nelse\nStrongBrakes
        = ( ((planet:getGravity(planet.center + (vec3(0,0,1)*planet.radius)):len())
        * core.getConstructMass()) <  LastMaxBrake)\nif not StrongBrakes and velMag
        > MinAutopilotSpeed then\nmsgText = \"WARNING: Insufficient Brakes - Attempting
        coast landing, beware obstacles\"\nend\nif not AltitudeHold then\nToggleAltitudeHold()\nend\nAutoTakeoff
        = false\nBrakeLanding = true\nNav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,
        0)\nend\nend\nfunction ToggleAutoTakeoff()\nif AutoTakeoff then\n-- Turn it
        off, and also AltitudeHold cuz it's weird if you cancel and that's still going
        \nAutoTakeoff = false\nif AltitudeHold then\nToggleAltitudeHold()\nend\nelse\nif
        not AltitudeHold then\nToggleAltitudeHold()\nend\nAutoTakeoff = true\nHoldAltitude
        = core_altitude + AutoTakeoffAltitude\ngearExtended = false\nNav.control.retractLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(500)
        -- Hard set this for takeoff, you wouldn't use takeoff from a hangar\nBrakeIsOn
        = true\nend\nend\nfunction ToggleAltitudeHold()\nAltitudeHold = not AltitudeHold\nif
        AltitudeHold then\nAutoBrake = false\nAutopilot = false\nProgradeIsOn = false\nRetrogradeIsOn
        = false\nFollowMode = false\nBrakeLanding = false\nReentry = false\nautoRoll
        = true\nif (not gearExtended and not BrakeIsOn) or atmosphere() == 0 then
        -- Never autotakeoff in space\nAutoTakeoff = false\nHoldAltitude = core_altitude\nif
        Nav.axisCommandManager:getAxisCommandType(0) == 0 then\nNav.control.cancelCurrentControlMasterMode()\nend\nelse\nAutoTakeoff
        = true\nHoldAltitude = core_altitude + AutoTakeoffAltitude\ngearExtended =
        false\nNav.control.retractLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(500)\nBrakeIsOn
        = true -- Engage brake for warmup\nend\nelse\nautoRoll = autoRollPreference\nAutoTakeoff
        = false\nBrakeLanding = false\nReentry = false\nAutoTakeoff = false\nVectorToTarget
        = false\nend\nend\nfunction toggleFollowMode()\nif isRemote() == 1 then\nFollowMode
        = not FollowMode\nif FollowMode then \nAutopilot = false\nRetrogradeIsOn =
        false\nProgradeIsOn = false\nAutoBrake = false\nAltitudeHold = false\nReentry
        = false\nBrakeLanding = false\nAutoTakeoff = false\nOldGearExtended = gearExtended\ngearExtended
        = false\nNav.control.retractLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(500)
        -- Hard-set this for auto-follow\nelse\nBrakeIsOn = true\nautoRoll = autoRollPreference\ngearExtended
        = OldGearExtended\nif gearExtended then\nNav.control.extendLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(0)\nend\nend\nelse\nmsgText
        = \"Follow Mode only works with Remote controller\"\nFollowMode = false\nend\nend\nfunction
        AutopilotToggle()\n-- Toggle Autopilot, as long as the target isn't None\nif
        AutopilotTargetIndex > 0 and not Autopilot then\n-- If it's a custom location...
        \n-- Behavior is probably \n-- a. If not at the same nearest planet and in
        space and the target has gravity, autopilot to that planet\n-- a1. \n-- b.
        If at nearest planet but not in atmo (and the destination is in atmo), and
        destination is less than (radius) away or our orbit is not stable, auto-reentry\n--
        (IE if in an orbit, like from AP, it should wait until destination is on the
        correct side of the planet before engaging reentry)\n-- c.  If at correct
        planet and in atmo and alt hold isn't on and they aren't landed, engage altitude
        hold at that alt and speed\n-- d. If alt hold is on and we're within tolerance
        of our target altitude, slowly yaw toward the target position\n-- e. If our
        velocity vector is lined up to go over the target position, calculate our
        brake distance at current speed in atmo\n-- f. If our distance to the target
        (ignoring altitude) is within our current brakeDistance, engage brake-landing\n--
        f2. Should we even try to let this happen on ships with bad brakes.  Eventually,
        try that.  For now just don't let them use this\nif CustomTarget ~= nil then\nStrongBrakes
        = ( ((planet:getGravity(planet.center + (vec3(0,0,1)*planet.radius)):len())
        * core.getConstructMass()) <  LastMaxBrake)\nif not StrongBrakes and velMag
        > MinAutopilotSpeed then\nmsgText = \"Insufficient Brake Force\\nCoast landing
        will be inaccurate\"\nend\n-- Going to need to add all those conditions here.
        \ Let's start with the easiest.\nif unit.getAtmosphereDensity() > 0 then\nif
        not AltitudeHold then\n-- Autotakeoff gets engaged inside the toggle if conditions
        are met\nif not VectorToTarget then\nToggleVectorToTarget()\nend\n--if gearExtended
        or BrakeIsOn then\n--    ToggleAutoTakeoff()\n--else\n--    ToggleAltitudeHold()\n--end\nelse\n--
        Vector to target\nif not VectorToTarget then\nToggleVectorToTarget()\nend\nend
        -- TBH... this is the only thing we need to do, make sure Alt Hold is on.
        \ \nend\nelseif unit.getAtmosphereDensity() == 0 then -- Planetary autopilot\nAutopilot
        = true\nRetrogradeIsOn = false\nProgradeIsOn = false\nAutopilotRealigned =
        false\nFollowMode = false\nAltitudeHold = false\nBrakeLanding = false\nReentry
        = false\nAutoTakeoff = false\nend\nelse\nAutopilot = false\nAutopilotRealigned
        = false\nVectorToTarget = false\nend\nend\nfunction ToggleAutoBrake()\nif
        AutopilotTargetPlanetName ~= \"None\" and brakeInput == 0 and not AutoBrake
        then\nAutoBrake = true\nAutopilot = false\nProgradeIsOn = false\nRetrogradeIsOn
        = false\nFollowMode = false\nAltitudeHold = false\nBrakeLanding = false\nReentry
        = false\nAutoTakeoff = false\nelse\nAutoBrake = false\nend\nend\nfunction
        ProgradeToggle()\n-- Toggle Progrades\nProgradeIsOn = not ProgradeIsOn\nRetrogradeIsOn
        = false -- Don't let both be on\nAutopilot = false\nAltitudeHold = false\nAutoBrake
        = false\nFollowMode = false\nBrakeLanding = false\nReentry = false\nAutoTakeoff
        = false\nlocal Progradestring = \"Off\"\nif ProgradeIsOn then\nProgradestring
        = \"On\"\nend\nend\nfunction RetrogradeToggle()\n-- Toggle Retrogrades\nRetrogradeIsOn
        = not RetrogradeIsOn\nProgradeIsOn = false -- Don't let both be on\nAutopilot
        = false\nAltitudeHold = false\nAutoBrake = false\nFollowMode = false\nBrakeLanding
        = false\nReentry = false\nAutoTakeoff = false\nlocal Retrogradestring = \"Off\"\nif
        RetrogradeIsOn then\nRetrogradestring = \"On\"\nend\nend\nfunction BrakeToggle()\n--
        Toggle brakes\nBrakeIsOn = not BrakeIsOn\nif BrakeLanding then\nBrakeLanding
        = false\nautoRoll = autoRollPreference\nend\nif BrakeIsOn then\n-- If they
        turn on brakes, disable a few things\nAltitudeHold = false\nVectorToTarget
        = false\nAutoTakeoff = false\nReentry = false\n-- We won't abort interplanetary
        because that would fuck everyone.\nProgradeIsOn = false -- No reason to brake
        while facing prograde, but retrograde yes.\nBrakeLanding = false\nAutoLanding
        = false\nAltitudeHold = false -- And stop alt hold\nautoRoll = autoRollPreference\nend\nend\nfunction
        checkDamage(newContent)\nlocal percentDam = 0\ndamageMessage = \"\"\ncurrentConstructMass
        = constructMass()\nlocal maxShipHP = eleTotalMaxHp\nlocal curShipHP = 0\nlocal
        voxelDam = 100\nlocal damagedElements = 0\nlocal disabledElements = 0\nlocal
        colorMod = 0\nlocal color = \"\"\nfor k in pairs(elementsID) do\nlocal hp
        = 0\nlocal mhp = 0\nmhp = eleMaxHp(elementsID[k])\nhp = eleHp(elementsID[k])\ncurShipHP
        = curShipHP + hp\nif (hp < mhp) then \nif (hp == 0) then\ndisabledElements
        = disabledElements +1\nelse\ndamagedElements = damagedElements +1 \nend\n--
        Thanks to Jerico for the help and code starter for arrow markers!\nif RepairArrows
        and #markers == 0 then\nposition = vec3(core.getElementPositionById(elementsID[k]))\nlocal
        coreOffset = 16\nlocal x =  position.x - coreOffset\nlocal y =  position.y
        - coreOffset\nlocal z =  position.z - coreOffset\ntable.insert(markers, core.spawnArrowSticker(x,
        y, z+1, \"down\"))\ntable.insert(markers, core.spawnArrowSticker(x, y, z+1,
        \"down\"))\ncore.rotateSticker(markers[2],0,0,90)\ntable.insert(markers, core.spawnArrowSticker(x+1,
        y, z, \"north\"))\ntable.insert(markers, core.spawnArrowSticker(x+1, y, z,
        \"north\"))\ncore.rotateSticker(markers[4],90,90,0)\ntable.insert(markers,
        core.spawnArrowSticker(x-1, y, z, \"south\"))\ntable.insert(markers, core.spawnArrowSticker(x-1,
        y, z, \"south\"))\ncore.rotateSticker(markers[6],90,-90,0)\ntable.insert(markers,
        core.spawnArrowSticker(x, y-1, z, \"east\"))\ntable.insert(markers, core.spawnArrowSticker(x,
        y-1, z, \"east\"))\ncore.rotateSticker(markers[8],90,0,90)\ntable.insert(markers,
        core.spawnArrowSticker(x, y+1, z, \"west\"))\ntable.insert(markers, core.spawnArrowSticker(x,
        y+1, z, \"west\"))\ncore.rotateSticker(markers[10],-90,0,90)\ntable.insert(markers,
        elementsID[k])\nend\nelseif RepairArrows and #markers > 0 and markers[11]
        == elementsID[k] then\nfor j in pairs(markers) do\ncore.deleteSticker(markers[j])\nend\nmarkers
        = {}\nend\nend\npercentDam = mfloor((curShipHP * 100 / maxShipHP))\nif currentConstructMass
        < lastConstructMass then\nvoxelDam = math.ceil( 100*(currentConstructMass
        - updateMass()) / honeyCombMass)\nlastConstructMass = currentConstructMass\nend\nif
        voxelDam < 100 or percentDam < 100 then\nnewContent[#newContent + 1] = [[<g
        class=\"pbright txt\">]]\nif voxelDam < 100 then \ncolorMod = mfloor(voxelDam*2.55)\ncolor
        = stringf(\"rgb(%d,%d,%d)\", 255-colorMod, colorMod, 0)\nnewContent[#newContent
        + 1] = stringf([[<text class=\"txtbig txtmid\" x=50%% y=\"1015\" style=\"fill:%s\">Structural
        Integrity: %i %%</text>]], color, voxelDam)\nend\ncolorMod = mfloor(percentDam*2.55)\ncolor
        = stringf(\"rgb(%d,%d,%d)\", 255-colorMod, colorMod, 0)\nif percentDam < 100
        then\nnewContent[#newContent + 1] = stringf([[<text class=\"txtbig txtmid\"
        x=50%% y=\"1035\" style=\"fill:%s\">Elemental Integrity: %i %%</text>]], color,
        percentDam)\nif (disabledElements > 0) then \nnewContent[#newContent + 1]
        = stringf([[<text class=\"txtbig txtmid\" x=50%% y=\"1055\" style=\"fill:%s\">Disabled
        Modules: %i Damaged Modules: %i</text>]], color, disabledElements, damagedElements)\nelseif
        damagedElements > 0 then\nnewContent[#newContent + 1] = stringf([[<text class=\"txtbig
        txtmid\" x=50%% y=\"1055\"style=\"fill:%s\">Damaged Modules: %i</text>]],
        color, damagedElements)\nend\nend\nnewContent[#newContent + 1] = [[<\\g>]]\nend\nend\nfunction
        DrawCursorLine(newContent)\nlocal strokeColor = mfloor(utils.clamp((distance/(ResolutionWidth/4))*255,0,255))\nnewContent[#newContent
        + 1] = stringf(\"<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%,
        50%%)' />\",simulatedX, simulatedY, mfloor(PrimaryR+0.5) + strokeColor, mfloor(PrimaryG+0.5)-strokeColor,
        mfloor(PrimaryB+0.5)-strokeColor)\nend\nfunction getPitch(gravityDirection,
        forward, right)\nlocal horizontalForward = gravityDirection:cross(right):normalize_inplace()
        -- Cross forward?\nlocal pitch = math.acos(utils.clamp(horizontalForward:dot(-forward),
        -1, 1)) * constants.rad2deg -- acos?\nif horizontalForward:cross(-forward):dot(right)
        < 0 then pitch = -pitch end -- Cross right dot forward?\nreturn pitch\nend\nfunction
        saveVariables()\nif not dbHud then\nmsgText = \"No Databank Found, unable
        to save. \\nYou must have a Databank attached to ship prior to running the
        HUD autoconfigure\"\nmsgTimer = 5\nelseif valuesAreSet then\nif doubleCheck
        then\n-- If any values are set, wipe them all\nfor k,v in pairs(SaveableVariables)
        do\ndbHud.setStringValue(v,jencode(nil))\nend\n-- Not Including the auto vars\n--ResetAutoVars
        = true\n--for k,v in pairs(AutoVariables) do\n--    dbHud.setStringValue(v,
        jencode(nil))\n--end\nmsgText = \"Databank wiped. Get out of the seat, set
        the savable variables, \\nthen re-enter seat and hit ALT-7 again\"\nmsgTimer
        = 5\ndoubleCheck = false\nvaluesAreSet = false\nelse\nmsgText = \"Press ALT-7
        again to confirm wipe\"\ndoubleCheck = true\nend\nelse\nfor k,v in pairs(SaveableVariables)
        do\ndbHud.setStringValue(v,jencode(_G[v]))\nend\nmsgText = \"Saved Variables
        to Datacore\"\nResetAutoVars = false\nvaluesAreSet = true\nend\nend\nfunction
        CheckButtons()\nfor _,v in pairs(Buttons) do\nif v.hovered then\nv.toggleFunction()\nv.hovered
        = false\nend\nend\nend\nfunction SetButtonContains()\nlocal x = simulatedX
        + ResolutionWidth/2, simulatedY + ResolutionHeight/2\nlocal y = simulatedY
        + ResolutionHeight/2\nfor _,v in pairs(Buttons) do\n-- enableName, disableName,
        width, height, x, y, toggleVar, toggleFunction, drawCondition\nv.hovered =
        Contains(x,y,v.x,v.y,v.width,v.height)\nend\nend\nfunction DrawButton(newContent,
        toggle, hover, x, y, w, h, activeColor, inactiveColor, activeText, inactiveText)\nnewContent[#newContent
        + 1] = stringf(\"<rect x='%f' y='%f' width='%f' height='%f' fill='\",x, y,
        w, h)\nif toggle then \nnewContent[#newContent + 1] = stringf(\"%s'\", activeColor)\nelse\nnewContent[#newContent
        + 1] = inactiveColor\nend\nif hover then \nnewContent[#newContent + 1] = \"
        style='stroke:white; stroke-width:2'\"\nelse\nnewContent[#newContent + 1]
        = \" style='stroke:black; stroke-width:1'\"\nend    \nnewContent[#newContent
        + 1] = \"></rect>\"\nnewContent[#newContent + 1] = stringf(\"<text x='%f'
        y='%f' font-size='24' fill='\", x + w/2, y + (h/2) + 5)\nif toggle then\nnewContent[#newContent
        + 1] = \"black\"\nelse\nnewContent[#newContent + 1] = \"white\"\nend\nnewContent[#newContent
        + 1] = \"' text-anchor='middle' font-family='Montserrat'>\"\nif toggle then
        \nnewContent[#newContent + 1] = stringf(\"%s</text>\", activeText)\nelse\nnewContent[#newContent
        + 1] = stringf(\"%s</text>\", inactiveText)\nend\nend\nfunction DrawButtons(newContent)\nlocal
        defaultColor = \"rgb(50,50,50)'\"\nlocal onColor = \"rgb(210,200,200)\"\nlocal
        draw = DrawButton\nfor _,v in pairs(Buttons) do\n-- enableName, disableName,
        width, height, x, y, toggleVar, toggleFunction, drawCondition\nlocal disableName
        = v.disableName\nlocal enableName = v.enableName\nif type(disableName) ==
        \"function\" then\ndisableName = disableName()\nend\nif type(enableName) ==
        \"function\" then\nenableName = enableName()\nend\nif not v.drawCondition
        or v.drawCondition() then -- If they gave us a nil condition\ndraw(newContent,
        v.toggleVar(), v.hovered, v.x, v.y, v.width, v.height, onColor, defaultColor,
        disableName, enableName)\nend\nend\nend\nfunction DrawTank(newContent, updateTanks,
        x, nameSearchPrefix, nameReplacePrefix, tankTable, fuelTimeLeftTable, fuelPercentTable)
        \               \nlocal tankID = 1\nlocal tankName = 2\nlocal tankMaxVol =
        3\nlocal tankMassEmpty = 4\nlocal tankLastMass = 5\nlocal tankLastTime = 6\nlocal
        slottedTankType = \"\"\nlocal slottedTanks = 0\nlocal y1 = 350\nlocal y2 =
        360\nif isRemote() == 1 then\ny1 = y1-50\ny2 = y2-50\nend\nnewContent[#newContent
        + 1] = [[<g class=\"pdim txtfuel\">]]\nif nameReplacePrefix == \"ATMO\" then
        \nslottedTankType = \"atmofueltank\"\nelseif nameReplacePrefix == \"SPACE\"
        then\nslottedTankType = \"spacefueltank\"\nelse\nslottedTankType = \"rocketfueltank\"\nend\nslottedTanks
        = _G[slottedTankType..\"_size\"]\nif (#tankTable > 0) then\nfor i = 1, #tankTable
        do\nlocal name = string.sub(tankTable[i][tankName], 1, 12)\nlocal slottedIndex
        = 0\nfor j = 1, slottedTanks do\nif tankTable[i][tankName] == json.decode(unit[slottedTankType..\"_\"..j].getData()).name
        then\nslottedIndex = j\nbreak\nend\nend\nif updateTanks or fuelTimeLeftTable[i]
        == nil or fuelPercentTable[i] == nil then\nlocal fuelMassMax = 0\nlocal fuelMassLast
        = 0\nlocal fuelMass = 0\nlocal fuelLastTime = 0\nlocal curTime = system.getTime()\nif
        slottedIndex ~= 0 then\nfuelPercentTable[i] = json.decode(unit[slottedTankType..\"_\"..slottedIndex].getData()).percentage\nfuelTimeLeftTable[i]
        = json.decode(unit[slottedTankType..\"_\"..slottedIndex].getData()).timeLeft\nif
        fuelTimeLeftTable[i] == \"n/a\" then fuelTimeLeftTable[i] = 0 end\nelse\nfuelMass
        = (eleMass(tankTable[i][tankID])-tankTable[i][tankMassEmpty])\nfuelMassMax
        = tankTable[i][tankMaxVol]\nfuelPercentTable[i] = mfloor(0.5+fuelMass*100/fuelMassMax)\nfuelMassLast
        = tankTable[i][tankLastMass]\nfuelLastTime = tankTable[i][tankLastTime]\nif
        fuelMassLast <= fuelMass then\nfuelTimeLeftTable[i] = 0\nelse\nfuelTimeLeftTable[i]
        = mfloor(0.5+fuelMass / ((fuelMassLast - fuelMass) / (curTime - fuelLastTime)))\nend\ntankTable[i][tankLastMass]
        = fuelMass\ntankTable[i][tankLastTime] = curTime\nend\nend\nif name == nameSearchPrefix
        then \nname = stringf(\"%s %d\", nameReplacePrefix, i)\nend\nif slottedIndex
        == 0 then\nname = name..\" *\"\nend\nlocal fuelTimeDisplay\nif fuelTimeLeftTable[i]
        == 0 then \nfuelTimeDisplay = \"n/a\" \nelse\nfuelTimeDisplay = FormatTimeString(fuelTimeLeftTable[i])\nend\nif
        fuelPercentTable[i] ~= nil then\nlocal colorMod = mfloor(fuelPercentTable[i]*2.55)\nlocal
        color = stringf(\"rgb(%d,%d,%d)\", 255-colorMod, colorMod, 0)\nlocal class
        = \"\"\nif ((fuelTimeDisplay ~= \"n/a\" and fuelTimeLeftTable[i] < 120) or
        fuelPercentTable[i] < 5) then\nif updateTanks then \nclass = [[class=\"red\"]]\nend\nend\nnewContent[#newContent
        + 1] = stringf([[\n<text x=%d y=\"%d\" %s>%s</text>\n<text x=%d y=\"%d\" style=\"fill:%s\">%d%%
        %s</text>\n]], x, y1, class, name, x, y2, color, fuelPercentTable[i], fuelTimeDisplay)\ny1
        = y1+30\ny2 = y2+30\nend\nend\nend\nnewContent[#newContent + 1] = \"</g>\"\nend\nfunction
        HideInterplanetaryPanel()\nsystem.destroyWidgetPanel(panelInterplanetary)\npanelInterplanetary
        = nil\nend\nsystem.showScreen(1)\nfunction getRelativePitch(velocity) \nvelocity
        = vec3(velocity)\nlocal pitch = -math.deg(math.atan(velocity.y, velocity.z))
        + 180\n-- This is 0-360 where 0 is straight up\npitch = pitch - 90\n-- So
        now 0 is straight, but we can now get angles up to 420\nif pitch < 0 then\npitch
        = 360 + pitch \nend \n-- Now, if it's greater than 180, say 190, make it go
        to like -170\nif pitch > 180 then\npitch = -180 + (pitch-180) \nend\n-- And
        it's backwards.  \nreturn -pitch\nend\nfunction getRelativeYaw(velocity) \nvelocity
        = vec3(velocity)\nreturn math.deg(math.atan(velocity.y, velocity.x)) - 90\nend\nfunction
        AlignToWorldVector(vector, tolerance)\n-- Sets inputs to attempt to point
        at the autopilot target\n-- Meant to be called from Update or Tick repeatedly\nif
        tolerance == nil then\ntolerance = alignmentTolerance\nend\nvector = vec3(vector):normalize()\nlocal
        targetVec = (vec3(core.getConstructWorldOrientationForward()) - vector)\nlocal
        yawAmount = -getMagnitudeInDirection(targetVec, core.getConstructWorldOrientationRight())
        * AutopilotStrength\nlocal pitchAmount = -getMagnitudeInDirection(targetVec,
        core.getConstructWorldOrientationUp()) * AutopilotStrength\nyawInput2 = yawInput2
        - (yawAmount + (yawAmount - PreviousYawAmount) * DampingMultiplier)\npitchInput2
        = pitchInput2 + (pitchAmount + (pitchAmount - PreviousPitchAmount) * DampingMultiplier)\nPreviousYawAmount
        = yawAmount\nPreviousPitchAmount = pitchAmount\n-- Return true or false depending
        on whether or not we're aligned\nif math.abs(yawAmount) < tolerance and math.abs(pitchAmount)
        < tolerance then\nreturn true\nend\nreturn false\nend       \nfunction getAPEnableName()\nlocal
        name = AutopilotTargetName\nif name == nil then\nname = CustomTarget.name
        .. \" \" .. getDistanceDisplayString((vec3(core.getConstructWorldPos())-CustomTarget.position):len())\nend\nif
        name == nil then\nname = \"None\"\nend\nreturn \"Engage Autopilot: \" .. name\nend\nfunction
        getAPDisableName()\nlocal name = AutopilotTargetName\nif name == nil then\nname
        = CustomTarget.name\nend\nif name == nil then\nname = \"None\"\nend\nreturn
        \"Disable Autopilot: \" .. name\nend\n-- BEGIN BUTTON DEFINITIONS\n-- enableName,
        disableName, width, height, x, y, toggleVar, toggleFunction, drawCondition\nlocal
        buttonHeight = 50\nlocal buttonWidth = 260 -- Defaults\nlocal brake = MakeButton(\"Enable
        Brake Toggle\", \"Disable Brake Toggle\", buttonWidth, buttonHeight, ResolutionWidth/2
        - buttonWidth/2, ResolutionHeight/2 + 350, function() return brakeToggle end,
        function() brakeToggle = not brakeToggle if(brakeToggle) then msgText = \"Brakes
        in Toggle Mode\" else msgText = \"Brakes in Default Mode\" end end)\nMakeButton(\"Align
        Prograde\", \"Disable Prograde\", buttonWidth, buttonHeight, ResolutionWidth/2
        - buttonWidth/2 - 50 - brake.width, ResolutionHeight/2 - buttonHeight + 380,
        function() return ProgradeIsOn end, ProgradeToggle)\nMakeButton(\"Align Retrograde\",
        \"Disable Retrograde\", buttonWidth, buttonHeight, ResolutionWidth/2 - buttonWidth/2
        + brake.width + 50, ResolutionHeight/2 - buttonHeight + 380, function() return
        RetrogradeIsOn end, RetrogradeToggle, function() return unit.getAtmosphereDensity()
        == 0 end) -- Hope this works\nlocal apbutton = MakeButton(getAPEnableName,
        getAPDisableName, 600, 60, ResolutionWidth/2 - 600/2, ResolutionHeight/2 -
        60/2 - 400, function() return Autopilot end, AutopilotToggle)\nMakeButton(\"Save
        Position\", \"Save Position\", 200, apbutton.height, apbutton.x + apbutton.width
        + 30, apbutton.y, function() return false end, AddNewLocation)\nMakeButton(\"Clear
        Position\", \"Clear Position\", 200, apbutton.height, apbutton.x - 200 - 30,
        apbutton.y, function() return true end, ClearCurrentPosition, function() return
        AutopilotTargetIndex > 0 and CustomTarget ~= nil end)\n-- The rest are sort
        of standardized\nbuttonHeight = 60\nbuttonWidth = 300\nlocal x = 10\nlocal
        y = ResolutionHeight/2  - 300\nMakeButton(\"Enable Turn and Burn\", \"Disable
        Turn and Burn\", buttonWidth, buttonHeight, x, y, function() return TurnBurn
        end, ToggleTurnBurn)\nMakeButton(\"Engage Altitude Hold\", \"Disable Altitude
        Hold\", buttonWidth, buttonHeight, x + buttonWidth + 20, y, function() return
        AltitudeHold end, ToggleAltitudeHold)\ny = y + buttonHeight + 20\nMakeButton(\"Engage
        Autoland\", \"Disable Autoland\", buttonWidth, buttonHeight, x, y, function()
        return AutoLanding end, ToggleAutoLanding)\nMakeButton(\"Engage Auto Takeoff\",
        \"Disable Auto Takeoff\", buttonWidth, buttonHeight, x + buttonWidth + 20,
        y, function() return AutoTakeoff end, ToggleAutoTakeoff)\ny = y + buttonHeight
        + 20\nMakeButton(\"Engage Follow Mode\", \"Disable Follow Mode\", buttonWidth,
        buttonHeight, x, y, function() return FollowMode end, ToggleFollowMode, function()
        return isRemote() == 1 end)\nMakeButton(\"Engage Glide Reentry\", \"Disable
        Glide Reentry\", buttonWidth, buttonHeight, x + buttonWidth + 20, y, function()
        return ReentryMode end, function() ReentryMode = not ReentryMode if(ReentryMode)
        then msgText = \"Reentry Mode Enabled. Press G when aligned with planet for
        reentry\" else msgText = \"Reentry Mode Disabled.  Normal Landing with G\"
        end end)\ny = y + buttonHeight + 20\nMakeButton(\"Enable Emergency Warp\",
        \"Disable Emergency Warp\", buttonWidth, buttonHeight, x, y, function() return
        EmergencyWarp end, function() EmergencyWarp = not EmergencyWarp if(EmergencyWarp)
        then msgText = \"Emergency Warp Enabled\" else msgText = \"Emergency Warp
        Disabled\" end end, function() return warpdrive ~= nil end)\nMakeButton(\"Show
        Orbit Display\", \"Hide Orbit Display\", buttonWidth, buttonHeight, x + buttonWidth
        + 20, y, function() return displayOrbit end, function() displayOrbit = not
        displayOrbit if(displayOrbit) then msgText = \"Orbit Display Enabled\" else
        msgText = \"Orbit Display Disabled\" end end)\ncoroutine.yield() -- Just to
        make sure\ny = y + buttonHeight + 20\nMakeButton(\"Enable Repair Arrows\",
        \"Disable Repair Arrows\", buttonWidth, buttonHeight, x+ buttonWidth + 20,
        y, function() return RepairArrows end, function() RepairArrows = not RepairArrows
        if(RepairArrows) then msgText = \"Repair Arrows Enabled\" else msgText = \"Repair
        Arrows Diabled\" end end, function() return isRemote() == 1 end)\n-- HUD -
        https://github.com/Rezoix/DU-hud with major modifications by Archeageo\nfunction
        updateHud(newContent)\nlocal altitude = core_altitude\nlocal velocity = core.getVelocity()\nlocal
        speed = vec3(velocity):len()\nlocal worldV = vec3(core.getWorldVertical())\nlocal
        constrF = vec3(core.getConstructWorldOrientationForward())\nlocal constrR
        = vec3(core.getConstructWorldOrientationRight())\nlocal constrV = vec3(core.getConstructWorldOrientationUp())\nlocal
        pitch = getPitch(worldV, constrF, constrR)--180 - getRoll(worldV, constrR,
        constrF)\nlocal roll = getRoll(worldV, constrF, constrR) --getRoll(worldV,
        constrF, constrR)\nlocal originalRoll = roll\nlocal originalPitch = mfloor(pitch)\nlocal
        bottomText = \"ROLL\"\nlocal grav = core.getWorldGravity()\nlocal gravity
        = vec3(grav):len()\nlocal atmos = atmosphere()\nlocal throt = mfloor(unit.getThrottle())\nlocal
        spd = speed*3.6\nlocal flightValue = unit.getAxisCommandValue(0)\nlocal flightStyle
        = GetFlightStyle()\nif (atmos == 0) then\nif (speed > 5) then\npitch = getRelativePitch(velocity)\nroll
        = getRelativeYaw(velocity)\nelse\npitch = 0\nroll = 0\nend\nbottomText = \"YAW\"\nend\n--
        CRUISE/ODOMETER\nnewContent[#newContent + 1] = LastOdometerOutput\n-- DAMAGE\nnewContent[#newContent
        + 1] = damageMessage\n-- RADAR\nnewContent[#newContent + 1] = radarMessage\n--
        FUEL TANKS\nif (UpdateCount % FuelUpdateDelay == 0) then updateTanks = true
        end\nDrawTank(newContent, updateTanks, 1700, \"Atmospheric \", \"ATMO\", atmoTanks,
        fuelTimeLeft, fuelPercent)\nDrawTank(newContent, updateTanks, 1800, \"Space
        fuel t\", \"SPACE\", spaceTanks, fuelTimeLeftS, fuelPercentS)\nDrawTank(newContent,
        updateTanks, 1600, \"Rocket fuel \", \"ROCKET\", rocketTanks, fuelTimeLeftR,
        fuelPercentR)\nif updateTanks then\nupdateTanks = false\nUpdateCount = 0\nend\nUpdateCount
        = UpdateCount + 1\n-- PRIMARY FLIGHT INSTRUMENTS\nDrawVerticalSpeed(newContent,
        altitude, atmos) -- Weird this is draw during remote control...?\nif isRemote()
        == 0 then     \nDrawPitchDisplay(newContent, pitch)\n-- Don't even draw this
        in freelook\nif not IsInFreeLook() then\nDrawArtificialHorizon(newContent,
        originalPitch, originalRoll, atmos)\nend\nDrawRollDisplay(newContent, roll,
        bottomText)\nDrawAltitudeDisplay(newContent, altitude, atmos)\nend   \nDrawThrottle(newContent,
        flightStyle, throt, flightValue)                   \n-- PRIMARY DATA DISPLAYS\nDrawSpeed(newContent,
        spd)                          \nDrawWarnings(newContent)                    \nDisplayOrbit(newContent)
        \               \nif screen_2 then\nlocal pos = vec3(core.getConstructWorldPos())\nlocal
        x = 960+pos.x/MapXRatio\nlocal y = 450+pos.y/MapYRatio\nscreen_2.moveContent(YouAreHere,
        (x-80)/19.2, (y-80)/10.8)\nend\nend\nfunction IsInFreeLook()\nreturn system.isViewLocked()
        == 0 and userControlScheme ~= \"Keyboard\" and isRemote() == 0\nend\nfunction
        HUDPrologue(newContent)\nlocal bright = rgb\nlocal dim = rgbdim\nlocal brightOrig
        = rgb\nlocal dimOrig = rgbdim\nif IsInFreeLook() and not brightHud then\nbright
        = [[rgb(]] .. mfloor(PrimaryR *0.4 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.4
        + 0.5) .. \",\" .. mfloor(PrimaryB * 0.3 + 0.5) .. [[)]]\ndim = [[rgb(]] ..
        mfloor(PrimaryR *0.3 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.3 + 0.5) .. \",\"
        .. mfloor(PrimaryB * 0.2 + 0.5) .. [[)]]\nend\n-- When applying styles, apply
        color first, then type (e.g. \"bright line\")\n-- so that \"fill:none\" gets
        applied\nnewContent[#newContent + 1] = stringf([[\n<head>\n<style>\nbody {margin:
        0}\nsvg {position:absolute;top:0;left:0;font-family:Montserrat;} \n.txt {font-size:10px;font-weight:bold;}\n.txttick
        {font-size:12px;font-weight:bold;}\n.txtbig {font-size:14px;font-weight:bold;}\n.line
        {stroke-width:2px;fill:none}\n.linethick {stroke-width:3px;fill:none}\n.warnings
        {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}\n.warn {fill:orange;font-size:24px}\n.crit
        {fill:darkred;font-size:28px}\n.bright {fill:%s;stroke:%s}\n.pbright {fill:%s;stroke:%s}\n.dim
        {fill:%s;stroke:%s}\n.pdim {fill:%s;stroke:%s}\n.red {fill:red;stroke:red}\n.redout
        {fill:none;stroke:red}\n.op30 {opacity:0.3}\n.op10 {opacity:0.1}\n.txtstart
        {text-anchor:start}\n.txtend {text-anchor:end}\n.txtmid {text-anchor:middle}\n.txtvspd
        {font-family:sans-serif;font-weight:normal}\n.txtvspdval {font-size:20px}\n.txtfuel
        {font-size:11px;font-weight:bold}\n.txtorb {font-size:12px}\n.txtorbbig {font-size:18px}\n.hudver
        {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}\n.msg
        {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}\n.cursor {stroke:white}\n.ah
        {opacity:0.1;fill:#0083cb;stroke:black;stroke-width:2px}\n.ahg {opacity:0.3;fill:#6b5835}\n</style>\n</head>\n<body>\n<svg
        height=\"100%%\" width=\"100%%\" viewBox=\"0 0 1920 1080\">\n]], bright, bright,
        brightOrig, brightOrig, dim, dim, dimOrig, dimOrig)\nend\nfunction HUDEpilogue(newContent)\nnewContent[#newContent
        + 1] = \"</svg>\"\nend\nfunction DrawSpeed(newContent, spd)\nlocal ys1 = 375\nlocal
        ys2 = 390\nlocal xg = 1200\nlocal yg1 = 710\nlocal yg2 = 720\nnewContent[#newContent
        + 1] = [[<g class=\"pdim txt txtend\">]]\nif isRemote() == 1 then\nys1 = 60\nys2
        = 75\nxg = 1120\nyg1 = 55\nyg2 = 65\nend\nnewContent[#newContent + 1] = stringf([[\n<g
        class=\"pbright txtmid\">\n<text x=\"960\" y=\"%d\">SPEED</text>\n<text class=\"txtbig\"
        x=\"960\" y=\"%d\">%d km/h</text>\n</g>\n</g>]], ys1, ys2, mfloor(spd))\nend\nfunction
        DrawOdometer(newContent, totalDistanceTrip, totalDistanceTravelled, flightStyle,
        flightTime)\nlocal xg = 1200\nlocal yg1 = 710\nlocal yg2 = 720\nlocal atmos
        = atmosphere()\nlocal gravity = core.g()\nlocal massMax = 0\nlocal reqThrust
        = 0\nrefreshLastMaxBrake(gravity)\nmaxThrust = Nav:maxForceForward()\ntotalMass
        = constructMass()\nlocal accel = (vec3(core.getWorldAcceleration()):len()/9.80665)\nif
        gravity > 0.1 then \nreqThrust = totalMass * gravity\nmaxMass = maxThrust
        / gravity\nend\nnewContent[#newContent + 1] = [[<g class=\"pdim txt txtend\">]]\nif
        isRemote() == 1 then\nxg = 1120\nyg1 = 55\nyg2 = 65\nelse -- We only show
        atmo when not remote\nnewContent[#newContent + 1] = stringf([[\n<text x=\"770\"
        y=\"710\">ATMOSPHERE</text>\n<text x=\"770\" y=\"720\">%.2f</text>\n]], atmos)\nend\nnewContent[#newContent
        + 1] = stringf([[\n<g class=\"pbright txtmid\">\n</g>\n<text x=\"%d\" y=\"%d\">GRAVITY</text>\n<text
        x=\"%d\" y=\"%d\">%.2f g</text>\n<text x=\"%d\" y=\"%d\">ACCEL</text>\n<text
        x=\"%d\" y=\"%d\">%.2f g</text>\n]], xg, yg1, xg, yg2, (gravity/9.80665),
        xg, yg1+20, xg, yg2+20, accel)\nnewContent[#newContent + 1] = [[<g class=\"pbright
        txt\">\n<path class=\"linethick\" d=\"M 660 0 L 700 35 Q 960 55 1240 35 L
        1280 0\"/>]]\nif isRemote() == 0 then\nnewContent[#newContent + 1] = stringf([[\n<text
        class=\"txtstart\" x=\"700\" y=\"20\" >Trip: %.2f km</text>\n<text class=\"txtstart\"
        x=\"700\" y=\"30\">Lifetime: %.2f Mm</text>\n<text class=\"txtstart\" x=\"830\"
        y=\"20\">Trip Time: %s</text>\n<text class=\"txtstart\" x=\"830\" y=\"30\">Total
        Time: %s</text>\n<text class=\"txtstart\" x=\"970\" y=\"20\">Mass: %.2f Tons</text>\n<text
        class=\"txtend\" x=\"1240\" y=\"10\">Max Brake: %.2f kN</text>\n<text class=\"txtend\"
        x=\"1240\" y=\"30\">Max Thrust: %.2f kN</text>\n<text class=\"txtbig txtmid\"
        x=\"960\" y=\"360\">%s</text>\n]], totalDistanceTrip, (totalDistanceTravelled/1000),
        FormatTimeString(flightTime), FormatTimeString(totalFlightTime), (totalMass/1000),
        (LastMaxBrake/1000), (maxThrust/1000), flightStyle)\nif gravity > 0.1 then\nnewContent[#newContent
        + 1] = stringf([[\n<text class=\"txtstart\" x=\"970\" y=\"30\">Max Mass: %.2f
        Tons</text>\n<text class=\"txtend\" x=\"1240\" y=\"20\">Req Thrust: %.2f kN</text>\n]],
        (maxMass/1000), (reqThrust/1000))\nelse\nnewContent[#newContent + 1] = [[\n<text
        class=\"txtstart\" x=\"970\" y=\"30\" text-anchor=\"start\">Max Mass: n/a</text>\n<text
        class=\"txtend\" x=\"1240\" y=\"20\" text-anchor=\"end\">Req Thrust: n/a</text>\n]]\nend\nelse
        -- If remote controlled, draw stuff near the top so it's out of the way\nnewContent[#newContent
        + 1] = stringf([[<text class=\"txtbig txtmid\" x=\"960\" y=\"33\">%s</text>]],flightStyle)\nend\nnewContent[#newContent
        + 1] = \"</g>\"\nend\nfunction DrawThrottle(newContent, flightStyle, throt,
        flightValue)\nlocal y1 = 665\nlocal y2 = 675\nif isRemote() == 1 then\ny1
        = 55\ny2 = 65\nend\nlocal label = \"CRUISE\"\nlocal unit = \"km/h\"\nlocal
        value = flightValue\nif (flightStyle == \"TRAVEL\" or flightStyle == \"AUTOPILOT\")
        then\nlabel = \"THROT\"\nunit = \"%\"\nvalue = throt\nlocal throtclass = \"dim\"\nif
        throt < 0 then throtclass = \"red\" end\nnewContent[#newContent + 1] = stringf([[<g
        class=\"%s\">\n<path class=\"linethick\" d=\"M 792 550 L 785 550 L 785 650
        L 792 650\"/>\n<g transform=\"translate(0 %d)\">\n<polygon points=\"798,650
        810,647 810,653\"/>\n</g>]], throtclass, (1-math.abs(throt)))\nend\nnewContent[#newContent
        + 1] = stringf([[\n<g class=\"pbright txtstart\">\n<text x=\"783\" y=\"%d\">%s</text>\n<text
        x=\"783\" y=\"%d\">%d %s</text>\n</g>\n</g>]], y1, label, y2, value, unit)\nend\n--
        Draw vertical speed indicator - Code by lisa-lionheart \nfunction DrawVerticalSpeed(newContent,
        altitude, atmos) \nif (altitude < 200000 and atmos == 0 ) or (altitude and
        atmos > 0) then \nlocal velocity = vec3(core.getWorldVelocity())\nlocal up
        = vec3(core.getWorldVertical()) * -1\nlocal vSpd = (velocity.x * up.x) + (velocity.y
        * up.y) + (velocity.z * up.z)\nlocal angle = 0       \nif math.abs(vSpd) >
        1 then\nangle = 45 * math.log(math.abs(vSpd), 10)      \nif vSpd < 0 then\nangle
        = -angle\nend                                \nend\nnewContent[#newContent
        + 1] =  stringf([[\n<g class=\"pbright txt txtvspd\" transform=\"translate(1525
        250) scale(0.6)\">\n<text x=\"31\" y=\"-41\">1000</text>\n<text x=\"-10\"
        y=\"-65\">100</text>\n<text x=\"-54\" y=\"-45\">10</text>\n<text x=\"-73\"
        y=\"3\">O</text>\n<text x=\"-56\" y=\"52\">-10</text>\n<text x=\"-14\" y=\"72\">-100</text>\n<text
        x=\"29\" y=\"50\">-1000</text>\n<text x=\"85\" y=\"0\" class=\"txtvspdval
        txtend\">%d m/s</text>\n<g class=\"linethick\">\n<path d=\"m-41 75 2.5-4.4m17
        12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75
        2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32
        53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40
        17-7 7\"/>\n<circle r=\"90\" />\n</g>\n<path transform=\"rotate(%d)\" d=\"m-0.094-7c-22
        2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z\"
        />\n</g>\n]], mfloor(vSpd), mfloor(angle))\nend\nend\nfunction DrawPitchDisplay(newContent,
        pitch)\n-- PITCH DISPLAY\nlocal pitchC = mfloor(pitch)\nlocal len = 0\nlocal
        baseY = 540\nlocal tickerPath = [[<path class=\"dim line\" d=\"]]\nnewContent[#newContent
        + 1] = [[<g class=\"dim txttick\">]]\nfor i = mfloor(pitchC-25-pitchC%5+0.5),mfloor(pitchC+25+pitchC%5+0.5),5
        do\nif (i%10==0) then\nnum = i\nif (num > 180) then\nnum = -180 + (num-180)\nelseif
        (num < -180) then\nnum = 180 + (num+180)\nend\nnewContent[#newContent + 1]
        = stringf([[\n<text x=\"1195\" y=\"%f\">%d</text>]], baseY + (-i*5 + pitch*5
        + 5), num)\nend\nif (i%10==0) then\nlen = 30\nelseif (i%5==0) then\nlen =
        20\nelse\nlen = 7\nend\nlocal y = baseY + (-i*5 + pitch*5)\ntickerPath = stringf([[%s
        M 1140 %f h %d]], tickerPath, y, len)\nend\nnewContent[#newContent + 1] =
        \"</g>\"\nnewContent[#newContent + 1] = tickerPath\nnewContent[#newContent
        + 1] = stringf([[\"/>\n<polygon class=\"bright\" points=\"1138,540 1120,535
        1120,545\"/>\n<g class=\"pdim txt\">\n<text x=\"1180\" y=\"380\">PITCH</text>\n<text
        x=\"1180\" y=\"390\">%d deg</text>\n</g>\n]], pitchC)\nend\nfunction DrawAltitudeDisplay(newContent,
        altitude, atmos)\nif (altitude < 200000 and atmos == 0 ) or (altitude and
        atmos > 0) then    \n-- Many thanks to Nistus on Discord for his assistance
        with the altimeter.\nlocal altC = mfloor((altitude)/10)\nlocal num = 0\nlocal
        len = 0\nlocal baseY = 540\nlocal tickerPath = [[<path class=\"dim line\"
        d=\"]]\nnewContent[#newContent + 1] = [[<g class=\"dim txttick txtend\">]]\nfor
        i = mfloor(altC-25-altC%5+0.5),mfloor(altC+25+altC%5+0.5),5 do\nif (i%10==0)
        then\nnum = i*10\nnewContent[#newContent + 1] = stringf([[<text x=\"745\"
        y=\"%f\">%d</text>]], baseY + (-i*5 + altitude*.5+5), num)\nend\nlen = 5\nif
        (i%10==0) then\nlen = 30\nelseif (i%5==0) then\nlen = 15\nend\ntickerPath
        = stringf([[%s M 780 %f h %d]], tickerPath, baseY + (-i*5 + altitude*.5),
        -len)\nend\nnewContent[#newContent + 1] = \"</g>\"\nnewContent[#newContent
        + 1] = tickerPath\nnewContent[#newContent + 1] = stringf([[\"/>\n<polygon
        class=\"bright\" points=\"782,540 800,535 800,545\"/>\n<g class=\"pdim txt\">\n<text
        x=\"770\" y=\"380\">ALTITUDE</text>\n<text x=\"770\" y=\"390\">%d m</text>\n</g>]],
        mfloor(altitude))\nend\nend\nfunction DrawArtificialHorizon(newContent, originalPitch,
        originalRoll, atmos)\n--** CIRCLE ALTIMETER  - Base Code from Discord @Rainsome
        = Youtube CaptainKilmar** \nlocal horizonRadius = circleRad -- Aliased global\nif
        horizonRadius > 0 and unit.getClosestPlanetInfluence() > 0 then\nif originalPitch
        > 90 and atmos == 0 then\noriginalPitch = 90-(originalPitch-90)\nelseif originalPitch
        < -90 and atmos == 0 then\noriginalPitch = -90 - (originalPitch+90)\nend\nnewContent[#newContent
        + 1] = stringf([[\n<circle class=\"ah\" r=\"%f\" cx=\"960\" cy=\"540\"/>\n<clipPath
        id=\"cut\"><circle r=\"%f\" cx=\"960\" cy=\"540\"/></clipPath>\n<rect class=\"ahg\"
        x=\"%f\" y=\"%f\" height=\"%f\" width=\"%f\" clip-path=\"url(#cut)\" transform=\"rotate(%f
        960 540)\"/>]], horizonRadius, (horizonRadius-1), (960-horizonRadius), (540
        + horizonRadius*(originalPitch/90)),(horizonRadius*2), (horizonRadius*2),
        (-1*originalRoll))\nend\nend\nfunction DrawRollDisplay(newContent, roll, bottomText)\nlocal
        rollC = mfloor(roll)\nlocal sign = 0\nlocal num = 0\nlocal len = 0\nnewContent[#newContent
        + 1] = [[<g class=\"txttick dim\">]]\nfor i = mfloor(rollC-30-rollC%5+0.5),mfloor(rollC+30+rollC%5+0.5),5
        do\nlocal rot = i - roll\nnewContent[#newContent + 1] = stringf([[<g transform=\"rotate(%f,960,460)\">]],
        rot)\nif (i%10==0) then\nsign = i/math.abs(i)\nif i == 0 then\nsign = 0\nend\nnum
        = math.abs(i)\nif (num > 180) then\nnum = 180 + (180-num) \nend\nnewContent[#newContent
        + 1] = stringf([[\n<text x=\"960\" y=\"760\">%d</text>]], mfloor(sign*num+0.5))\nend\nlen
        = 5\nif (i%10==0) then\nlen = 15\nelseif (i%5==0) then\nlen = 10\nend\nnewContent[#newContent
        + 1] = stringf([[<line x1=\"960\" y1=\"730\" x2=\"960\" y2=\"%d\"/></g>]],
        730+len)\nend\nnewContent[#newContent + 1] = stringf([[</g>\n<polygon class=\"bright\"
        points=\"960,725 955,707 965,707\"/>\n<g class=\"pdim txt txtmid\">\n<text
        x=\"960\" y=\"688\">%s</text>\n<text x=\"960\" y=\"698\">%d deg</text>\n</g>]],
        bottomText, mfloor(roll))\nend\nfunction DrawWarnings(newContent)\nnewContent[#newContent
        + 1] = stringf([[<text class=\"hudver\" x=\"1900\" y=\"1070\">DU Hud Version:
        %.3f</text>]],versionNumber)\nnewContent[#newContent + 1] = [[<g class=\"warnings\">]]\nif
        unit.isMouseControlActivated() == 1 then\nnewContent[#newContent + 1] = [[<text
        x=\"960\" y=\"550\">Warning: Invalid Control Scheme Detected</text>]]\nnewContent[#newContent
        + 1] = [[<text x=\"960\" y=\"600\">Keyboard Scheme must be selected</text>]]\nnewContent[#newContent
        + 1] = [[<text x=\"960\" y=\"650\">Set your preferred scheme in Lua Parameters
        instead</text>]]\nend\nlocal warningX = 960\nlocal brakeY = 860\nlocal gearY
        = 900\nlocal hoverY = 930\nlocal apY = 225\nlocal turnBurnY = 150\nlocal gyroY
        = 960\nif isRemote() == 1 then\nbrakeY = 135\ngearY = 155\nhoverY = 175\napY
        = 115\nturnBurnY = 95\nend\nif BrakeIsOn then\nnewContent[#newContent + 1]
        = stringf([[<text x=\"%d\" y=\"%d\">Brake Engaged</text>]],warningX, brakeY)\nend\nif
        GyroIsOn then\nnewContent[#newContent + 1] = stringf([[<text x=\"%d\" y=\"%d\">Gyro
        Enabled</text>]],warningX, gyroY)\nend\nif gearExtended then\nif hasGear then
        \nnewContent[#newContent + 1] = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Gear
        Extended</text>]], warningX, gearY)\nelse\nnewContent[#newContent + 1] = stringf([[<text
        x=\"%d\" y=\"%d\">Landed (G: Takeoff)</text>]], warningX, gearY)\nend\nnewContent[#newContent
        + 1] = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Hover Height: %s</text>]],
        warningX, hoverY, getDistanceDisplayString(Nav:getTargetGroundAltitude()))\nend\nif
        AutoBrake and AutopilotTargetPlanetName ~= \"None\" then\nif brakeInput ==
        0 then\nnewContent[#newContent + 1] = stringf([[<text class=\"warn\" x=\"%d\"
        y=\"%d\">Auto-Braking when within %s of %s</text>]], warningX, apY, getDistanceDisplayString(maxBrakeDistance),
        AutopilotTargetPlanet.name)\nelse\nnewContent[#newContent + 1] = stringf([[<text
        class=\"warn\" x=\"%d\" y=\"%d\">Auto-Braking until eccentricity: %f begins
        to increase</text>]],warningX, apY, round(orbit.eccentricity,2))\nend\nelseif
        Autopilot and AutopilotTargetPlanetName ~= \"None\" then\nnewContent[#newContent
        + 1] = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Autopilot %s</text>]],warningX,
        apY, AutopilotStatus)\nelseif FollowMode then\nnewContent[#newContent + 1]
        = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Follow Mode Engaged</text>]],
        warningX, apY)\nelseif AltitudeHold then\nif AutoTakeoff then\nnewContent[#newContent
        + 1] = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Ascent to %s</text>]],warningX,
        apY, getDistanceDisplayString(HoldAltitude))\nif BrakeIsOn then\nnewContent[#newContent
        + 1] = stringf([[<text class=\"crit\" x=\"%d\" y=\"%d\">Throttle Up and Disengage
        Brake For Takeoff</text>]], warningX, apY + 50)\nend\nelse\nnewContent[#newContent
        + 1] = stringf([[<text class=\"warn\" x=\"%d\" y=\"%d\">Altitude Hold: %s</text>]],
        warningX, apY, getDistanceDisplayString2(HoldAltitude))\nend\nend\nif BrakeLanding
        then\nif StrongBrakes then\nnewContent[#newContent + 1] = stringf([[<text
        x=\"%d\" y=\"%d\">Brake-Landing</text>]], warningX, apY)\nelse\nnewContent[#newContent
        + 1] = stringf([[<text x=\"%d\" y=\"%d\">Coast-Landing</text>]], warningX,
        apY)\nend\nend\nif TurnBurn then\nnewContent[#newContent + 1] = stringf([[<text
        class=\"crit\" x=\"%d\" y=\"%d\">Turn & Burn Braking</text>]], warningX, turnBurnY)\nend\nif
        VectorToTarget then\nnewContent[#newContent + 1] = stringf([[<text class=\"warn\"
        x=\"%d\" y=\"%d\">%s</text>]], warningX, turnBurnY,VectorStatus)\nend\nnewContent[#newContent
        + 1] = \"</g>\"\nend\nfunction DisplayOrbit(newContent)\nif orbit ~= nil and
        unit.getAtmosphereDensity() < 0.2 and planet ~= nil and orbit.apoapsis ~=
        nil and orbit.periapsis ~= nil and orbit.period ~= nil and displayOrbit then\n--
        If orbits are up, let's try drawing a mockup\nlocal orbitMapX = 75\nlocal
        orbitMapY = 0\nlocal orbitMapSize = 250 -- Always square\nlocal pad = 4\norbitMapY
        = orbitMapY + pad                        \nlocal orbitInfoYOffset = 15\nlocal
        x = orbitMapX + orbitMapSize + orbitMapX/2 + pad\nlocal y = orbitMapY + orbitMapSize/2
        + 5 + pad\nlocal rx, ry, scale, xOffset\nrx = orbitMapSize/4\nxOffset = 0\nnewContent[#newContent
        + 1] = [[<g class=\"pbright txtorb txtmid\">]]\n-- Draw a darkened box around
        it to keep it visible\nnewContent[#newContent + 1] = stringf('<rect width=\"%f\"
        height=\"%d\" rx=\"10\" ry=\"10\" x=\"%d\" y=\"%d\" style=\"fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;\"
        />', orbitMapSize+orbitMapX*2, orbitMapSize+orbitMapY, pad, pad)\nif orbit.periapsis
        ~= nil and orbit.apoapsis ~= nil then\nscale = (orbit.apoapsis.altitude +
        orbit.periapsis.altitude + planet.radius*2)/(rx*2)\nry = (planet.radius +
        orbit.periapsis.altitude + (orbit.apoapsis.altitude - orbit.periapsis.altitude)/2)/scale
        * (1-orbit.eccentricity)\nxOffset = rx - orbit.periapsis.altitude/scale -
        planet.radius/scale\nlocal ellipseColor = \"\"\nif orbit.periapsis.altitude
        <= 0 then\nellipseColor = 'redout'\nend\nnewContent[#newContent + 1] = stringf([[<ellipse
        class=\"%s line\" cx=\"%f\" cy=\"%f\" rx=\"%f\" ry=\"%f\"/>]], ellipseColor,
        orbitMapX + orbitMapSize/2 + xOffset + pad, orbitMapY + orbitMapSize/2 + pad,
        rx, ry)\nnewContent[#newContent + 1] = stringf('<circle cx=\"%f\" cy=\"%f\"
        r=\"%f\" stroke=\"white\" stroke-width=\"3\" fill=\"blue\" />', orbitMapX
        + orbitMapSize/2 + pad, orbitMapY + orbitMapSize/2 + pad, planet.radius/scale)
        \nend\nif orbit.apoapsis ~= nil and orbit.apoapsis.speed < MaxGameVelocity
        and orbit.apoapsis.speed > 0 then\nnewContent[#newContent + 1] = stringf([[<line
        class=\"pdim op30 linethick\" x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"/>]],x
        - 35, y-5, orbitMapX + orbitMapSize/2 + rx + xOffset, y-5)\nnewContent[#newContent
        + 1] = stringf([[<text x=\"%f\" y=\"%f\">Apoapsis</text>]], x, y)\ny  = y
        + orbitInfoYOffset\nnewContent[#newContent + 1] = stringf([[<text x=\"%f\"
        y=\"%f\">%s</text>]], x, y,  getDistanceDisplayString(orbit.apoapsis.altitude))\ny
        \ = y + orbitInfoYOffset\nnewContent[#newContent + 1] = stringf([[<text x=\"%f\"
        y=\"%f\">%s</text>]], x, y, FormatTimeString(orbit.timeToApoapsis))\ny  =
        y + orbitInfoYOffset\nnewContent[#newContent + 1] = stringf([[<text x=\"%f\"
        y=\"%f\">%s</text>]], x, y, getSpeedDisplayString(orbit.apoapsis.speed))\nend\ny
        = orbitMapY + orbitMapSize/2 + 5 + pad\nx = orbitMapX - orbitMapX/2+10 + pad\nif
        orbit.periapsis ~= nil and orbit.periapsis.speed < MaxGameVelocity and orbit.periapsis.speed
        > 0 then\nnewContent[#newContent + 1] = stringf([[<line class=\"pdim op30
        linethick\" x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"/>]], x + 35, y-5, orbitMapX
        + orbitMapSize/2 - rx + xOffset, y-5)\nnewContent[#newContent + 1] = stringf([[<text
        x=\"%f\" y=\"%f\">Periapsis</text>]], x, y)\ny  = y + orbitInfoYOffset\nnewContent[#newContent
        + 1] = stringf([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y,  getDistanceDisplayString(orbit.periapsis.altitude))\ny
        \ = y + orbitInfoYOffset\nnewContent[#newContent + 1] = stringf([[<text x=\"%f\"
        y=\"%f\">%s</text>]], x, y, FormatTimeString(orbit.timeToPeriapsis))\ny  =
        y + orbitInfoYOffset\nnewContent[#newContent + 1] = stringf([[<text x=\"%f\"
        y=\"%f\">%s</text>]], x, y, getSpeedDisplayString(orbit.periapsis.speed))\nend\n--
        Add a label for the planet\nnewContent[#newContent + 1] = stringf([[<text
        class=\"txtorbbig\" x=\"%f\" y=\"%d\">%s</text>]], orbitMapX + orbitMapSize/2
        + pad, 20 + pad, planet.name)\nif orbit.period ~= nil and orbit.periapsis
        ~= nil and orbit.apoapsis ~= nil then\nlocal apsisRatio = (orbit.timeToApoapsis/orbit.period)
        * 2 * math.pi\n-- x = xr * cos(t)\n-- y = yr * sin(t)\nlocal shipX = rx *
        math.cos(apsisRatio)\nlocal shipY = ry * math.sin(apsisRatio)\nnewContent[#newContent
        + 1] = stringf('<circle cx=\"%f\" cy=\"%f\" r=\"5\" stroke=\"white\" stroke-width=\"3\"
        fill=\"white\" />', orbitMapX + orbitMapSize/2 + shipX + xOffset + pad, orbitMapY
        + orbitMapSize/2 + shipY + pad)\nend\nnewContent[#newContent + 1] = [[</g>]]\n--
        Once we have all that, we should probably rotate the entire thing so that
        the ship is always at the bottom so you can see AP and PE move?\nend\nend\n--
        Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom
        with minor modifications\nfunction Atlas()\nreturn {\n[0] = {\n[1]={\nGM=6930729684,\nbodyId=1,\ncenter={x=17465536.000,y=22665536.000,z=-34464.000},\nname='Madis',\nplanetarySystemId=0,\nradius=44300\n},\n[2]={\nGM=157470826617,\nbodyId=2,\ncenter={x=-8.000,y=-8.000,z=-126303.000},\nname='Alioth',\nplanetarySystemId=0,\nradius=126068\n},\n[3]={\nGM=11776905000,\nbodyId=3,\ncenter={x=29165536.000,y=10865536.000,z=65536.000},\nname='Thades',\nplanetarySystemId=0,\nradius=49000\n},\n[4]={\nGM=14893847582,\nbodyId=4,\ncenter={x=-13234464.000,y=55765536.000,z=465536.000},\nname='Talemai',\nplanetarySystemId=0,\nradius=57450\n},\n[5]={\nGM=16951680000,\nbodyId=5,\ncenter={x=-43534464.000,y=22565536.000,z=-48934464.000},\nname='Feli',\nplanetarySystemId=0,\nradius=60000\n},\n[6]={\nGM=10502547741,\nbodyId=6,\ncenter={x=52765536.000,y=27165538.000,z=52065535.000},\nname='Sicari',\nplanetarySystemId=0,\nradius=51100\n},\n[7]={\nGM=13033380591,\nbodyId=7,\ncenter={x=58665538.000,y=29665535.000,z=58165535.000},\nname='Sinnen',\nplanetarySystemId=0,\nradius=54950\n},\n[8]={\nGM=18477723600,\nbodyId=8,\ncenter={x=80865538.000,y=54665536.000,z=-934463.940},\nname='Teoma',\nplanetarySystemId=0,\nradius=62000\n},\n[9]={\nGM=18606274330,\nbodyId=9,\ncenter={x=-94134462.000,y=12765534.000,z=-3634464.000},\nname='Jago',\nplanetarySystemId=0,\nradius=61590\n},\n[10]={\nGM=78480000,\nbodyId=10,\ncenter={x=17448118.224,y=22966846.286,z=143078.820},\nname='Madis
        Moon 1',\nplanetarySystemId=0,\nradius=10000\n},\n[11]={\nGM=237402000,\nbodyId=11,\ncenter={x=17194626.000,y=22243633.880,z=-214962.810},\nname='Madis
        Moon 2',\nplanetarySystemId=0,\nradius=11000\n},\n[12]={\nGM=265046609,\nbodyId=12,\ncenter={x=17520614.000,y=22184730.000,z=-309989.990},\nname='Madis
        Moon 3',\nplanetarySystemId=0,\nradius=15005\n},\n[21]={\nGM=2118960000,\nbodyId=21,\ncenter={x=457933.000,y=-1509011.000,z=115524.000},\nname='Alioth
        Moon 1',\nplanetarySystemId=0,\nradius=30000\n},\n[22]={\nGM=2165833514,\nbodyId=22,\ncenter={x=-1692694.000,y=729681.000,z=-411464.000},\nname='Alioth
        Moon 4',\nplanetarySystemId=0,\nradius=30330\n},\n[26]={\nGM=68234043600,\nbodyId=26,\ncenter={x=-1404835.000,y=562655.000,z=-285074.000},\nname='Sanctuary',\nplanetarySystemId=0,\nradius=83400\n},\n[30]={\nGM=211564034,\nbodyId=30,\ncenter={x=29214402.000,y=10907080.695,z=433858.200},\nname='Thades
        Moon 1',\nplanetarySystemId=0,\nradius=14002\n},\n[31]={\nGM=264870000,\nbodyId=31,\ncenter={x=29404193.000,y=10432768.000,z=19554.131},\nname='Thades
        Moon 2',\nplanetarySystemId=0,\nradius=15000\n},\n[40]={\nGM=141264000,\nbodyId=40,\ncenter={x=-13503090.000,y=55594325.000,z=769838.640},\nname='Talemai
        Moon 2',\nplanetarySystemId=0,\nradius=12000\n},\n[41]={\nGM=106830900,\nbodyId=41,\ncenter={x=-12800515.000,y=55700259.000,z=325207.840},\nname='Talemai
        Moon 3',\nplanetarySystemId=0,\nradius=11000\n},\n[42]={\nGM=264870000,\nbodyId=42,\ncenter={x=-13058408.000,y=55781856.000,z=740177.760},\nname='Talemai
        Moon 1',\nplanetarySystemId=0,\nradius=15000\n},\n[50]={\nGM=499917600,\nbodyId=50,\ncenter={x=-43902841.780,y=22261034.700,z=-48862386.000},\nname='Feli
        Moon 1',\nplanetarySystemId=0,\nradius=14000\n},\n[70]={\nGM=396912600,\nbodyId=70,\ncenter={x=58969616.000,y=29797945.000,z=57969449.000},\nname='Sinnen
        Moon 1',\nplanetarySystemId=0,\nradius=17000\n},\n[100]={\nGM=13975172474,\nbodyId=100,\ncenter={x=98865536.000,y=-13534464.000,z=-934461.990},\nname='Lacobus',\nplanetarySystemId=0,\nradius=55650\n},\n[101]={\nGM=264870000,\nbodyId=101,\ncenter={x=98905288.170,y=-13950921.100,z=-647589.530},\nname='Lacobus
        Moon 3',\nplanetarySystemId=0,\nradius=15000\n},\n[102]={\nGM=444981600,\nbodyId=102,\ncenter={x=99180968.000,y=-13783862.000,z=-926156.400},\nname='Lacobus
        Moon 1',\nplanetarySystemId=0,\nradius=18000\n},\n[103]={\nGM=211503600,\nbodyId=103,\ncenter={x=99250052.000,y=-13629215.000,z=-1059341.400},\nname='Lacobus
        Moon 2',\nplanetarySystemId=0,\nradius=14000\n},\n[110]={\nGM=9204742375,\nbodyId=110,\ncenter={x=14165536.000,y=-85634465.000,z=-934464.300},\nname='Symeon',\nplanetarySystemId=0,\nradius=49050\n},\n[120]={\nGM=7135606629,\nbodyId=120,\ncenter={x=2865536.700,y=-99034464.000,z=-934462.020},\nname='Ion',\nplanetarySystemId=0,\nradius=44950\n},\n[121]={\nGM=106830900,\nbodyId=121,\ncenter={x=2472916.800,y=-99133747.000,z=-1133582.800},\nname='Ion
        Moon 1',\nplanetarySystemId=0,\nradius=11000\n},\n[122]={\nGM=176580000,\nbodyId=122,\ncenter={x=2995424.500,y=-99275010.000,z=-1378480.700},\nname='Ion
        Moon 2',\nplanetarySystemId=0,\nradius=15000\n}  \n}\n}\nend\natlas = Atlas()\nfor
        k,v in pairs(atlas[0]) do\nif minAtlasX == nil or v.center.x < minAtlasX then\nminAtlasX
        = v.center.x\nend\nif maxAtlasX == nil or v.center.x > maxAtlasX then\nmaxAtlasX
        = v.center.x\nend\nif minAtlasY == nil or v.center.y < minAtlasY then\nminAtlasY
        = v.center.y\nend\nif maxAtlasY == nil or v.center.y > maxAtlasY then\nmaxAtlasY
        = v.center.y\nend\nend\nGalaxyMapHTML = \"\" -- No starting SVG tag so we
        can add it where we want it\n-- Figure out our scale here... \nlocal xRatio
        = 1.1*(maxAtlasX - minAtlasX)/1920 -- Add 10% for padding\nlocal yRatio =
        1.4*(maxAtlasY - minAtlasY)/1080 -- Extra so we can get ion back in\nfor k,v
        in pairs(atlas[0]) do\n-- Draw a circle at the scaled coordinates\nlocal x
        = 960 + (v.center.x / xRatio)\nlocal y = 540 + (v.center.y / yRatio)\nGalaxyMapHTML
        = GalaxyMapHTML .. '<circle cx=\"' .. x .. '\" cy=\"' .. y .. '\" r=\"' ..
        (v.radius/xRatio)*30 .. '\" stroke=\"white\" stroke-width=\"3\" fill=\"blue\"
        />'\nif not string.match(v.name, \"Moon\") and not string.match(v.name, \"Sanctuary\")
        then\nGalaxyMapHTML = GalaxyMapHTML .. \"<text x='\" .. x .. \"' y='\" ..
        y + (v.radius/xRatio)*30 + 20 .. \"' font-size='28' fill=\" .. rgb .. \" text-anchor='middle'
        font-family='Montserrat'>\" .. v.name .. \"</text>\"\nend\nend\n-- Draw a
        'You Are Here' - face edition\nlocal pos = vec3(core.getConstructWorldPos())\nlocal
        x = 960 + pos.x/xRatio\nlocal y = 540 + pos.y/yRatio\nGalaxyMapHTML = GalaxyMapHTML
        .. '<circle cx=\"' .. x .. '\" cy=\"' .. y .. '\" r=\"5\" stroke=\"white\"
        stroke-width=\"3\" fill=\"red\"/>'\nGalaxyMapHTML = GalaxyMapHTML .. \"<text
        x='\" .. x .. \"' y='\" .. y - 50 .. \"' font-size='36' fill='darkred' text-anchor='middle'
        font-family='Bank' font-weight='bold'>You Are Here</text>\"\nGalaxyMapHTML
        = GalaxyMapHTML .. [[</svg>]]\nMapXRatio = xRatio\nMapYRatio = yRatio\nif
        screen_2 then\nscreen_2.setHTML('<svg width=\"100%\" height=\"100%\" viewBox=\"0
        0 1920 1080\">' .. GalaxyMapHTML) -- This is permanent and doesn't change\n--
        Draw a 'You Are Here' - screen edition\nlocal pos = vec3(core.getConstructWorldPos())\nlocal
        x = 960 + pos.x/xRatio\nlocal y = 540 + pos.y/yRatio\nGalaxyMapHTML = '<svg><circle
        cx=\"80\" cy=\"80\" r=\"5\" stroke=\"white\" stroke-width=\"3\" fill=\"red\"/>'\nGalaxyMapHTML
        = GalaxyMapHTML .. \"<text x='80' y='105' font-size='18' fill=\" .. rgb ..
        \" text-anchor='middle' font-family='Montserrat''>You Are Here</text></svg>\"\nYouAreHere
        = screen_2.addContent((x-80)/19.20, (y-80)/10.80, GalaxyMapHTML)\nend\nfunction
        PlanetRef() \n--[[                    START OF LOCAL IMPLEMENTATION DETAILS
        \            ]]--\n-- Type checks\nlocal function isNumber(n)  return type(n)
        \          == 'number' end\nlocal function isSNumber(n) return type(tonumber(n))
        == 'number' end\nlocal function isTable(t)   return type(t)           == 'table'
        \ end\nlocal function isString(s)  return type(s)           == 'string' end\nlocal
        function isVector(v)  return isTable(v)\nand isNumber(v.x and v.y and v.z)
        end\nlocal function isMapPosition(m) return isTable(m) and isNumber(m.latitude
        \ and\nm.longitude and\nm.altitude  and\nm.bodyId    and\nm.systemId) end\n--
        Constants\nlocal deg2rad    = math.pi/180\nlocal rad2deg    = 180/math.pi\nlocal
        epsilon    = 1e-10\nlocal num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\nlocal
        posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..\nnum ..
        \ ',' .. num .. '}'\n-- Utilities\nlocal utils  = require('cpml.utils')\nlocal
        vec3   = require('cpml.vec3')\nlocal clamp  = utils.clamp\nlocal function
        float_eq(a,b)\nif a == 0 then return math.abs(b) < 1e-09 end\nif b == 0 then
        return math.abs(a) < 1e-09 end\nreturn math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\nend\nlocal
        function formatNumber(n)\nlocal result = string.gsub(\nstring.reverse(stringf('%.4f',n)),\n'^0*%.?','')\nreturn
        result == '' and '0' or string.reverse(result)\nend\nlocal function formatValue(obj)\nif
        isVector(obj) then\nreturn stringf('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y,
        obj.z)\nend\nif isTable(obj) and not getmetatable(obj) then\nlocal list =
        {}\nlocal nxt  = next(obj)\nif type(nxt) == 'nil' or nxt == 1 then -- assume
        this is an array\nlist = obj\nelse\nfor k,v in pairs(obj) do\nlocal value
        = formatValue(v)\nif type(k) == 'number' then\ntable.insert(list, stringf('[%s]=%s',
        k, value))\nelse\ntable.insert(list, stringf('%s=%s',   k, value))\nend\nend\nend\nreturn
        stringf('{%s}', table.concat(list, ','))\nend\nif isString(obj) then\nreturn
        stringf(\"'%s'\", obj:gsub(\"'\",[[\\']]))\nend\nreturn tostring(obj)\nend\n--
        CLASSES\n-- BodyParameters: Attributes of planetary bodies (planets and moons)\nlocal
        BodyParameters = {}\nBodyParameters.__index = BodyParameters\nBodyParameters.__tostring
        =\nfunction(obj, indent)\nlocal sep = indent or ''\nlocal keys = {}\nfor k
        in pairs(obj) do table.insert(keys, k) end\ntable.sort(keys)\nlocal list =
        {}\nfor _, k in ipairs(keys) do\nlocal value = formatValue(obj[k])\nif type(k)
        == 'number' then\ntable.insert(list, stringf('[%s]=%s', k, value))\nelse\ntable.insert(list,
        stringf('%s=%s', k, value))\nend\nend\nif indent then\nreturn stringf('%s%s',\nindent,\ntable.concat(list,
        ',\\n' .. indent))\nend\nreturn stringf('{%s}', table.concat(list, ','))\nend\nBodyParameters.__eq
        = function(lhs, rhs)\nreturn lhs.planetarySystemId == rhs.planetarySystemId
        and\nlhs.bodyId            == rhs.bodyId            and\nfloat_eq(lhs.radius,
        rhs.radius)               and\nfloat_eq(lhs.center.x, rhs.center.x)           and\nfloat_eq(lhs.center.y,
        rhs.center.y)           and\nfloat_eq(lhs.center.z, rhs.center.z)           and\nfloat_eq(lhs.GM,
        rhs.GM)\nend\nlocal function mkBodyParameters(systemId, bodyId, radius, worldCoordinates,
        GM)\n-- 'worldCoordinates' can be either table or vec3\nassert(isSNumber(systemId),\n'Argument
        1 (planetarySystemId) must be a number:' .. type(systemId))\nassert(isSNumber(bodyId),\n'Argument
        2 (bodyId) must be a number:' .. type(bodyId))\nassert(isSNumber(radius),\n'Argument
        3 (radius) must be a number:' .. type(radius))\nassert(isTable(worldCoordinates),\n'Argument
        4 (worldCoordinates) must be a array or vec3.' ..\ntype(worldCoordinates))\nassert(isSNumber(GM),\n'Argument
        5 (GM) must be a number:' .. type(GM))\nreturn setmetatable({planetarySystemId
        = tonumber(systemId),\nbodyId            = tonumber(bodyId),\nradius            =
        tonumber(radius),\ncenter            = vec3(worldCoordinates),\nGM                =
        tonumber(GM) }, BodyParameters)\nend\n-- MapPosition: Geographical coordinates
        of a point on a planetary body.\nlocal MapPosition = {}\nMapPosition.__index
        = MapPosition\nMapPosition.__tostring = function(p)\nreturn stringf('::pos{%d,%d,%s,%s,%s}',\np.systemId,\np.bodyId,\nformatNumber(p.latitude*rad2deg),\nformatNumber(p.longitude*rad2deg),\nformatNumber(p.altitude))\nend\nMapPosition.__eq
        \      = function(lhs, rhs)\nreturn lhs.bodyId   == rhs.bodyId              and\nlhs.systemId
        == rhs.systemId            and\nfloat_eq(lhs.latitude,   rhs.latitude)  and\nfloat_eq(lhs.altitude,
        \  rhs.altitude)  and\n(float_eq(lhs.longitude, rhs.longitude) or\nfloat_eq(lhs.latitude,
        math.pi/2)      or\nfloat_eq(lhs.latitude, -math.pi/2))\nend\n-- latitude
        and longitude are in degrees while altitude is in meters\nlocal function mkMapPosition(overload,
        bodyId, latitude, longitude, altitude)\nlocal systemId = overload -- Id or
        '::pos{...}' string\nif isString(overload) and not longitude and not altitude
        and\nnot bodyId    and not latitude then\nsystemId, bodyId, latitude, longitude,
        altitude =\nstring.match(overload, posPattern)\nassert(systemId, 'Argument
        1 (position string) is malformed.')\nelse\nassert(isSNumber(systemId),\n'Argument
        1 (systemId) must be a number:' .. type(systemId))\nassert(isSNumber(bodyId),\n'Argument
        2 (bodyId) must be a number:' .. type(bodyId))\nassert(isSNumber(latitude),\n'Argument
        3 (latitude) must be in degrees:' .. type(latitude))\nassert(isSNumber(longitude),\n'Argument
        4 (longitude) must be in degrees:' .. type(longitude))\nassert(isSNumber(altitude),\n'Argument
        5 (altitude) must be in meters:' .. type(altitude))\nend\nsystemId  = tonumber(systemId)\nbodyId
        \   = tonumber(bodyId)\nlatitude  = tonumber(latitude)\nlongitude = tonumber(longitude)\naltitude
        \ = tonumber(altitude)\nif bodyId == 0 then -- this is a hack to represent
        points in space\nreturn setmetatable({latitude  = latitude,\nlongitude = longitude,\naltitude
        \ = altitude,\nbodyId    = bodyId,\nsystemId  = systemId}, MapPosition)\nend\nreturn
        setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),\nlongitude = deg2rad*(longitude
        % 360),\naltitude  = altitude,\nbodyId    = bodyId,\nsystemId  = systemId},
        MapPosition)\nend\n-- PlanetarySystem - map body IDs to BodyParameters\nlocal
        PlanetarySystem = {}\nPlanetarySystem.__index = PlanetarySystem\nPlanetarySystem.__tostring
        =\nfunction (obj, indent)\nlocal sep = indent and (indent .. '  ' )\nlocal
        bdylist = {}\nlocal keys = {}\nfor k in pairs(obj) do table.insert(keys, k)
        end\ntable.sort(keys)\nfor _, bi in ipairs(keys) do\nbdy = obj[bi]\nlocal
        bdys = BodyParameters.__tostring(bdy, sep)\nif indent then\ntable.insert(bdylist,\nstringf('[%s]={\\n%s\\n%s}',\nbi,
        bdys, indent))\nelse\ntable.insert(bdylist, stringf('  [%s]=%s', bi, bdys))\nend\nend\nif
        indent then\nreturn stringf('\\n%s%s%s',\nindent,\ntable.concat(bdylist, ',\\n'
        .. indent),\nindent)\nend\nreturn stringf('{\\n%s\\n}', table.concat(bdylist,
        ',\\n'))\nend\nlocal function mkPlanetarySystem(referenceTable)\nlocal atlas
        = {}\nlocal pid\nfor _, v in pairs(referenceTable) do\nlocal id = v.planetarySystemId\nif
        type(id) ~= 'number' then\nerror('Invalid planetary system ID: ' .. tostring(id))\nelseif
        pid and id ~= pid then\nerror('Mismatch planetary system IDs: ' .. id .. '
        and '\n.. pid)\nend\nlocal bid = v.bodyId\nif type(bid) ~= 'number' then\nerror('Invalid
        body ID: ' .. tostring(bid))\nelseif atlas[bid] then\nerror('Duplicate body
        ID: ' .. tostring(bid))\nend\nsetmetatable(v.center, getmetatable(vec3.unit_x))\natlas[bid]
        = setmetatable(v, BodyParameters)\npid = id\nend\nreturn setmetatable(atlas,
        PlanetarySystem)\nend\n-- PlanetaryReference - map planetary system ID to
        PlanetarySystem\nPlanetaryReference = {}\nlocal function mkPlanetaryReference(referenceTable)\nreturn
        setmetatable({ galaxyAtlas = referenceTable or {} },\nPlanetaryReference)\nend\nPlanetaryReference.__index
        \       = \nfunction(t,i)\nif type(i) == 'number' then\nlocal system = t.galaxyAtlas[i]\nreturn
        mkPlanetarySystem(system)\nend\nreturn rawget(PlanetaryReference, i)\nend\nPlanetaryReference.__pairs
        \       =\nfunction(obj)\nreturn  function(t, k)\nlocal nk, nv = next(t, k)\nreturn
        nk, nv and mkPlanetarySystem(nv)\nend, obj.galaxyAtlas, nil\nend\nPlanetaryReference.__tostring
        \    =\nfunction (obj)\nlocal pslist = {}\nfor _,ps in pairs(obj or {}) do\nlocal
        psi = ps:getPlanetarySystemId()\nlocal pss = PlanetarySystem.__tostring(ps,
        '    ')\ntable.insert(pslist,\nstringf('  [%s]={%s\\n  }', psi, pss))\nend\nreturn
        stringf('{\\n%s\\n}\\n', table.concat(pslist,',\\n'))\nend\nPlanetaryReference.BodyParameters
        = mkBodyParameters\nPlanetaryReference.MapPosition    = mkMapPosition\nPlanetaryReference.PlanetarySystem
        = mkPlanetarySystem\nfunction PlanetaryReference.createBodyParameters(planetarySystemId,\nbodyId,\nsurfaceArea,\naPosition,\nverticalAtPosition,\naltitudeAtPosition,\ngravityAtPosition)\nassert(isSNumber(planetarySystemId),\n'Argument
        1 (planetarySystemId) must be a number:' ..\ntype(planetarySystemId))\nassert(isSNumber(bodyId),\n'Argument
        2 (bodyId) must be a number:' .. type(bodyId))\nassert(isSNumber(surfaceArea),\n'Argument
        3 (surfaceArea) must be a number:' .. type(surfaceArea))\nassert(isTable(aPosition),\n'Argument
        4 (aPosition) must be an array or vec3:' ..\ntype(aPosition))\nassert(isTable(verticalAtPosition),\n'Argument
        5 (verticalAtPosition) must be an array or vec3:' ..\ntype(verticalAtPosition))\nassert(isSNumber(altitudeAtPosition),\n'Argument
        6 (altitude) must be in meters:' ..\ntype(altitudeAtPosition))\nassert(isSNumber(gravityAtPosition),\n'Argument
        7 (gravityAtPosition) must be number:' ..\ntype(gravityAtPosition))\nlocal
        radius   = math.sqrt(surfaceArea/4/math.pi)\nlocal distance = radius + altitudeAtPosition\nlocal
        center   = vec3(aPosition) + distance*vec3(verticalAtPosition)\nlocal GM       =
        gravityAtPosition * distance * distance\nreturn mkBodyParameters(planetarySystemId,
        bodyId, radius, center, GM)\nend\nPlanetaryReference.isMapPosition  = isMapPosition\nfunction
        PlanetaryReference:getPlanetarySystem(overload)\n--if galaxyAtlas then\nlocal
        planetarySystemId = overload\nif isMapPosition(overload) then\nplanetarySystemId
        = overload.systemId\nend\nif type(planetarySystemId) == 'number' then\nlocal
        system = self.galaxyAtlas[i]\nif system then\nif getmetatable(nv) ~= PlanetarySystem
        then\nsystem = mkPlanetarySystem(system)\nend\nreturn system\nend\nend\n--end\n--return
        nil\nend\nfunction PlanetarySystem:castIntersections(origin,\ndirection,\nsizeCalculator,\nbodyIds)\nlocal
        sizeCalculator = sizeCalculator or \nfunction (body) return 1.05*body.radius
        end\nlocal candidates = {}\nif bodyIds then\nfor _,i in ipairs(bodyIds) do
        candidates[i] = self[i] end\nelse\nbodyIds = {}\nfor k,body in pairs(self)
        do\ntable.insert(bodyIds, k)\ncandidates[k] = body\nend\nend\nlocal function
        compare(b1,b2)\nlocal v1 = candidates[b1].center - origin\nlocal v2 = candidates[b2].center
        - origin\nreturn v1:len() < v2:len()\nend\ntable.sort(bodyIds, compare)\nlocal
        dir = direction:normalize()\nfor i, id in ipairs(bodyIds) do\nlocal body   =
        candidates[id]\nlocal c_oV3  = body.center - origin\nlocal radius = sizeCalculator(body)\nlocal
        dot    = c_oV3:dot(dir)\nlocal desc   = dot^2 - (c_oV3:len2() - radius^2)\nif
        desc >= 0 then\nlocal root     = math.sqrt(desc)\nlocal farSide  = dot + root\nlocal
        nearSide = dot - root\nif nearSide > 0 then\nreturn body, farSide, nearSide\nelseif
        farSide > 0 then\nreturn body, farSide, nil\nend\nend\nend\nreturn nil, nil,
        nil\nend\nfunction PlanetarySystem:closestBody(coordinates)\nassert(type(coordinates)
        == 'table', 'Invalid coordinates.')\nlocal minDistance2, body\nlocal coord
        = vec3(coordinates)\nfor _,params in pairs(self) do\nlocal distance2 = (params.center
        - coord):len2()\nif not body or distance2 < minDistance2 then\nbody         =
        params\nminDistance2 = distance2\nend\nend\nreturn body\nend\nfunction PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)\nlocal
        mapPosition = overload\nif isString(overload) then\nmapPosition = mkMapPosition(overload)\nend\nif
        mapPosition.bodyId == 0 then\nreturn 0, vec3(mapPosition.latitude,\nmapPosition.longitude,\nmapPosition.altitude)\nend\nlocal
        params = self:getBodyParameters(mapPosition)\nif params then\nreturn mapPosition.bodyId,\nparams:convertToWorldCoordinates(mapPosition)\nend\nend\nfunction
        PlanetarySystem:getBodyParameters(overload)\nlocal bodyId = overload\nif isMapPosition(overload)
        then\nbodyId = overload.bodyId\nend\nassert(isSNumber(bodyId),\n'Argument
        1 (bodyId) must be a number:' .. type(bodyId))\nreturn self[bodyId]\nend\nfunction
        PlanetarySystem:getPlanetarySystemId()\nlocal k, v = next(self)\nreturn v
        and v.planetarySystemId\nend\nfunction BodyParameters:convertToMapPosition(worldCoordinates)\nassert(isTable(worldCoordinates),\n'Argument
        1 (worldCoordinates) must be an array or vec3:' ..\ntype(worldCoordinates))\nlocal
        worldVec  = vec3(worldCoordinates) \nif self.bodyId == 0 then\nreturn setmetatable({latitude
        \ = worldVec.x,\nlongitude = worldVec.y,\naltitude  = worldVec.z,\nbodyId
        \   = 0,\nsystemId  = self.planetarySystemId}, MapPosition)\nend\nlocal coords
        \   = worldVec - self.center\nlocal distance  = coords:len()\nlocal altitude
        \ = distance - self.radius\nlocal latitude  = 0\nlocal longitude = 0\nif not
        float_eq(distance, 0) then\nlocal phi = math.atan(coords.y, coords.x)\nlongitude
        = phi >= 0 and phi or (2*math.pi + phi)\nlatitude  = math.pi/2 - math.acos(coords.z/distance)\nend\nreturn
        setmetatable({latitude  = latitude,\nlongitude = longitude,\naltitude  = altitude,\nbodyId
        \   = self.bodyId,\nsystemId  = self.planetarySystemId}, MapPosition)\nend\nfunction
        BodyParameters:convertToWorldCoordinates(overload)\nlocal mapPosition = isString(overload)
        and\nmkMapPosition(overload) or overload\nif mapPosition.bodyId == 0 then
        -- support deep space map position\nreturn vec3(mapPosition.latitude,\nmapPosition.longitude,\nmapPosition.altitude)\nend\nassert(isMapPosition(mapPosition),\n'Argument
        1 (mapPosition) is not an instance of \"MapPosition\".')\nassert(mapPosition.systemId
        == self.planetarySystemId,\n'Argument 1 (mapPosition) has a different planetary
        system ID.')\nassert(mapPosition.bodyId == self.bodyId,\n'Argument 1 (mapPosition)
        has a different planetary body ID.')\nlocal xproj = math.cos(mapPosition.latitude)\nreturn
        self.center + (self.radius + mapPosition.altitude) *\nvec3(xproj*math.cos(mapPosition.longitude),\nxproj*math.sin(mapPosition.longitude),\nmath.sin(mapPosition.latitude))\nend\nfunction
        BodyParameters:getAltitude(worldCoordinates)\nreturn (vec3(worldCoordinates)
        - self.center):len() - self.radius\nend\nfunction BodyParameters:getDistance(worldCoordinates)\nreturn
        (vec3(worldCoordinates) - self.center):len()\nend\nfunction BodyParameters:getGravity(worldCoordinates)\nlocal
        radial = self.center - vec3(worldCoordinates) -- directed towards body\nlocal
        len2   = radial:len2()\nreturn (self.GM/len2) * radial/math.sqrt(len2)\nend\n--
        end of module\nreturn setmetatable(PlanetaryReference,\n{ __call = function(_,...)\nreturn
        mkPlanetaryReference(...)\nend })\nend\nfunction Keplers()\nlocal vec3       =
        require('cpml.vec3')\nlocal PlanetRef  = PlanetRef()\nlocal function isString(s)
        return type(s)   == 'string' end\nlocal function isTable(t)  return type(t)
        \  == 'table'  end\nlocal function float_eq(a,b)\nif a == 0 then return math.abs(b)
        < 1e-09 end\nif b == 0 then return math.abs(a) < 1e-09 end\nreturn math.abs(a
        - b) < math.max(math.abs(a),math.abs(b))*epsilon\nend\nKepler = {}\nKepler.__index
        = Kepler\nfunction Kepler:escapeAndOrbitalSpeed(altitude)\nassert(self.body)\n--
        P = -GMm/r and KE = mv^2/2 (no lorentz factor used)\n-- mv^2/2 = GMm/r\n--
        v^2 = 2GM/r\n-- v = sqrt(2GM/r1)\nlocal distance = altitude + self.body.radius\nif
        not float_eq(distance, 0) then\nlocal orbit = math.sqrt(self.body.GM/distance)\nreturn
        math.sqrt(2)*orbit, orbit\nend\nreturn nil, nil\nend\nfunction Kepler:orbitalParameters(overload,
        velocity)\nassert(self.body)\nassert(isTable(overload) or isString(overload))\nassert(isTable(velocity))\nlocal
        pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and\nself.body:convertToWorldCoordinates(overload)
        or\nvec3(overload)\nlocal v   = vec3(velocity)\nlocal r   = pos - self.body.center\nlocal
        v2  = v:len2()\nlocal d   = r:len()\nlocal mu  = self.body.GM\nlocal e   =
        ((v2 - mu/d)*r - r:dot(v)*v)/mu\nlocal a   = mu/(2*mu/d - v2)\nlocal ecc =
        e:len()\nlocal dir = e:normalize()\nlocal pd  = a*(1-ecc)\nlocal ad  = a*(1+ecc)\nlocal
        per = pd*dir + self.body.center\nlocal apo = ecc <= 1 and -ad*dir + self.body.center
        or nil\nlocal trm = math.sqrt(a*mu*(1-ecc*ecc))        \nlocal Period = apo
        and 2*math.pi*math.sqrt(a^3/mu)\n-- These are great and all, but, I need more.\nlocal
        trueAnomaly = math.acos((e:dot(r))/(ecc*d))\nif r:dot(v) < 0 then\ntrueAnomaly
        = -(trueAnomaly - 2*math.pi)\nend        \n-- Apparently... cos(EccentricAnomaly)
        = (cos(trueAnomaly) + eccentricity)/(1 + eccentricity * cos(trueAnomaly))\nlocal
        EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))\n--
        Then.... apparently if this is below 0, we should add 2pi to it\n-- I think
        also if it's below 0, we're past the apoapsis?\nlocal timeTau = EccentricAnomaly\nif
        timeTau < 0 then\ntimeTau = timeTau + 2*math.pi\nend\n-- So... time since
        periapsis...\n-- Is apparently easy if you get mean anomly.  t = M/n where
        n is mean motion, = 2*pi/Period\nlocal MeanAnomaly = timeTau - ecc * math.sin(timeTau)\nlocal
        TimeSincePeriapsis = 0\nlocal TimeToPeriapsis = 0\nlocal TimeToApoapsis =
        0\nif Period ~= nil then\nTimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)\n--
        Mean anom is 0 at periapsis, positive before it... and positive after it.\n--
        I guess this is why I needed to use timeTau and not EccentricAnomaly here\nTimeToPeriapsis
        = Period - TimeSincePeriapsis\nTimeToApoapsis = TimeToPeriapsis + Period/2\nif
        trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas
        because I needed this.\nTimeToPeriapsis = TimeSincePeriapsis\nTimeToApoapsis
        = TimeToPeriapsis + Period/2\nend\nif TimeToApoapsis > Period then\nTimeToApoapsis
        = TimeToApoapsis - Period\nend\nend\nreturn { periapsis       = { position
        \          = per,\nspeed              = trm/pd,\ncircularOrbitSpeed = math.sqrt(mu/pd),\naltitude
        \          = pd - self.body.radius},\napoapsis        = apo and\n{ position
        \          = apo,\nspeed              = trm/ad,\ncircularOrbitSpeed = math.sqrt(mu/ad),\naltitude
        \          = ad - self.body.radius},\ncurrentVelocity = v,\ncurrentPosition
        = pos,\neccentricity    = ecc,\nperiod          = Period,\neccentricAnomaly
        = EccentricAnomaly,\nmeanAnomaly = MeanAnomaly,\ntimeToPeriapsis = TimeToPeriapsis,\ntimeToApoapsis
        = TimeToApoapsis\n}\nend\nlocal function new(bodyParameters)\nlocal params
        = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,\nbodyParameters.bodyId,\nbodyParameters.radius,\nbodyParameters.center,\nbodyParameters.GM)\nreturn
        setmetatable({body = params}, Kepler)\nend\nreturn setmetatable(Kepler, {
        __call = function(_,...) return new(...) end })\nend\nfunction Kinematics()\nlocal
        Kinematic = {} -- just a namespace\nlocal C       = 30000000/3600\nlocal C2
        \     = C*C\nlocal ITERATIONS = 100 -- iterations over engine \"warm-up\"
        period\nlocal function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end\nfunction
        Kinematic.computeAccelerationTime(initial, acceleration, final)\n-- The low
        speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)\nlocal k1 = C*math.asin(initial/C)\nreturn
        (C * math.asin(final/C) - k1)/acceleration\nend\nfunction Kinematic.computeDistanceAndTime(initial,\nfinal,\nrestMass,\nthrust,\nt50,\nbrakeThrust)\nt50
        \           = t50 or 0\nbrakeThrust    = brakeThrust or 0 -- usually zero
        when accelerating\nlocal tau0     = lorentz(initial)\nlocal speedUp  = initial
        <= final\nlocal a0       = thrust * (speedUp and 1 or -1)/restMass\nlocal
        b0       = -brakeThrust/restMass\nlocal totA     = a0+b0\nif speedUp and totA
        <= 0 or not speedUp and totA >= 0 then\nreturn -1, -1 -- no solution\nend\nlocal
        distanceToMax, timeToMax = 0, 0\nif a0 ~= 0 and t50 > 0 then\nlocal k1  =
        math.asin(initial/C)\nlocal c1  = math.pi*(a0/2+b0)\nlocal c2  = a0*t50\nlocal
        c3  = C*math.pi\nlocal v = function(t)\nlocal w  = (c1*t - c2*math.sin(math.pi*t/2/t50)
        + c3*k1)/c3\nlocal tan = math.tan(w)\nreturn C*tan/math.sqrt(tan*tan+1)\nend\nlocal
        speedchk = speedUp and function(s) return s >= final end or\nfunction(s) return
        s <= final end\ntimeToMax  = 2*t50\nif speedchk(v(timeToMax)) then\nlocal
        lasttime = 0\nwhile math.abs(timeToMax - lasttime) > 0.5 do\nlocal t = (timeToMax
        + lasttime)/2\nif speedchk(v(t)) then\ntimeToMax = t \nelse\nlasttime = t\nend\nend\nend\n--
        There is no closed form solution for distance in this case.\n-- Numerically
        integrate for time t=0 to t=2*T50 (or less)\nlocal lastv = initial\nlocal
        tinc  = timeToMax/ITERATIONS\nfor step = 1, ITERATIONS do\nlocal speed = v(step*tinc)\ndistanceToMax
        = distanceToMax + (speed+lastv)*tinc/2\nlastv = speed\nend\nif timeToMax <
        2*t50 then\nreturn distanceToMax, timeToMax\nend\ninitial     = lastv\nend\nlocal
        k1       = C*math.asin(initial/C)\nlocal time     = (C * math.asin(final/C)
        - k1)/totA\nlocal k2       = C2 *math.cos(k1/C)/totA\nlocal distance = k2
        - C2 * math.cos((totA*time + k1)/C)/totA\nreturn distance+distanceToMax, time+timeToMax\nend\nfunction
        Kinematic.computeTravelTime(initial, acceleration, distance)\n-- The low speed
        limit of following is: t=(sqrt(2ad+v^2)-v)/a\n-- (from: d=vt+at^2/2)\nif distance
        == 0 then return 0 end\nif acceleration > 0 then\nlocal k1       = C*math.asin(initial/C)\nlocal
        k2       = C2*math.cos(k1/C)/acceleration\nreturn (C*math.acos(acceleration*(k2
        - distance)/C2) - k1)/acceleration\nend\nassert(initial > 0, 'Acceleration
        and initial speed are both zero.')\nreturn distance/initial\nend\nfunction
        Kinematic.lorentz(v) return lorentz(v) end\nreturn Kinematic\nend\nPlanetaryReference
        = PlanetRef()\ngalaxyReference = PlanetaryReference(Atlas())\nKinematic =
        Kinematics()\nKep = Keplers()\nInAtmo = (atmosphere() > 0)\nfunction getDistanceDisplayString(distance)\nlocal
        su = distance > 100000\nlocal result = \"\"\nif su then\n-- Convert to SU\nresult
        = round(distance/1000/200,1) .. \" SU\"\nelseif distance < 1000 then\nresult
        = round(distance,1) .. \" M\"\nelse\n-- Convert to KM\nresult = round(distance/1000,1)
        .. \" KM\"\nend\nreturn result\nend\nfunction getDistanceDisplayString2(distance)\nlocal
        su = distance > 100000\nlocal result = \"\"\nif su then\n-- Convert to SU\nresult
        = round(distance/1000/200,2) .. \" SU\"\nelseif distance < 1000 then\nresult
        = round(distance,2) .. \" M\"\nelse\n-- Convert to KM\nresult = round(distance/1000,2)
        .. \" KM\"\nend\nreturn result\nend\nfunction getSpeedDisplayString(speed)
        -- TODO: Allow options, for now just do kph\nreturn mfloor(round(speed*3.6,0)+0.5)
        .. \" km/h\" -- And generally it's not accurate enough to not twitch unless
        we round 0\nend\nfunction FormatTimeString(seconds)\nlocal hours = mfloor(seconds/3600)\nlocal
        minutes = mfloor(seconds/60%60)\nlocal seconds = mfloor(seconds%60)\nif seconds
        < 0 or hours < 0 or minutes < 0 then\nreturn \"0s\"\nend\nif hours > 0 then
        \nreturn hours .. \"h \" .. minutes .. \"m \" .. seconds .. \"s\"\nelseif
        minutes > 0 then\nreturn minutes .. \"m \" ..seconds..\"s\"\nelse\nreturn
        seconds..\"s\"\nend\nend\nfunction getMagnitudeInDirection(vector, direction)\n--return
        vec3(vector):project_on(vec3(direction)):len()\nvector = vec3(vector)\ndirection
        = vec3(direction):normalize()\nlocal result = vector*direction -- To preserve
        sign, just add them I guess\nreturn result.x + result.y + result.z\nend\nfunction
        UpdateAutopilotTarget()\n-- So the indices are weird.  I think we need to
        do a pairs\nif AutopilotTargetIndex == 0 then\nAutopilotTargetName = \"None\"\nAutopilotTargetPlanet
        = nil\nreturn true\nend\nlocal count = 0\nfor k,v in pairs(atlas[0]) do\ncount
        = count + 1\nif count == AutopilotTargetIndex then\nif v.center then -- Is
        a real atlas entry\nAutopilotTargetName = v.name\nAutopilotTargetPlanet =
        galaxyReference[0][k]\nAutopilotTargetCoords = vec3(AutopilotTargetPlanet.center)
        -- Aim center until we align\n-- Determine the end speed\n_, AutopilotEndSpeed
        = Kep(AutopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)\n--AutopilotEndSpeed
        = 0\n--AutopilotPlanetGravity = AutopilotTargetPlanet:getGravity(AutopilotTargetPlanet.center
        + vec3({1,0,0}) * AutopilotTargetOrbit):len() -- Any direction, at our orbit
        height\nAutopilotPlanetGravity = 0 -- This is inaccurate unless we integrate
        and we're not doing that.  \nAutopilotAccelerating = false\nAutopilotBraking
        = false\nAutopilotCruising = false \nAutoilot = false\nAutopilotRealigned
        = false\nAutopilotStatus = \"Aligning\"\nif CustomTarget ~= nil then\nif unit.getAtmosphereDensity()
        == 0 and InAtmo then\nsystem.addDataToWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)\nsystem.addDataToWidget(widgetMaxBrakeDistanceText,
        widgetMaxBrakeDistance)\nsystem.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)\nsystem.addDataToWidget(widgetCurBrakeDistanceText,
        widgetCurBrakeDistance)\nsystem.addDataToWidget(widgetTrajectoryAltitudeText,
        widgetTrajectoryAltitude)\nend\nsystem.addDataToWidget(widgetMaxMassText,
        widgetMaxMass)\nsystem.addDataToWidget(widgetTravelTimeText, widgetTravelTime)\nend\nCustomTarget
        = nil\nreturn true\nelse -- Is one of our fake locations with a .name, .position,
        and .atmosphere\n--AutopilotTargetName = \"None\"\nAutopilotTargetPlanet =
        nil\nAutopilotTargetName = nil\nCustomTarget = v\nend\nend\nend\nreturn false\nend\nfunction
        IncrementAutopilotTargetIndex()\nAutopilotTargetIndex = AutopilotTargetIndex
        + 1\nif AutopilotTargetIndex >  tablelength(atlas[0]) then \nAutopilotTargetIndex
        = 0\nend\nUpdateAutopilotTarget()\nend\nfunction DecrementAutopilotTargetIndex()\nAutopilotTargetIndex
        = AutopilotTargetIndex - 1\nif AutopilotTargetIndex < 0 then \nAutopilotTargetIndex
        = tablelength(atlas[0])\nend\nUpdateAutopilotTarget()\nend\nfunction GetAutopilotMaxMass()\nlocal
        apmaxmass = LastMaxBrake / (AutopilotTargetPlanet:getGravity(AutopilotTargetPlanet.center
        + (vec3(0,0,1)*AutopilotTargetPlanet.radius)):len()) \nreturn apmaxmass\nend\nfunction
        GetAutopilotTravelTime()\nAutopilotDistance = (AutopilotTargetPlanet.center
        - vec3(core.getConstructWorldPos())):len()\nlocal velocity = core.getWorldVelocity()
        \nlocal accelDistance, accelTime = Kinematic.computeDistanceAndTime(vec3(velocity):len(),\nMaxGameVelocity,
        -- From currently velocity to max\nconstructMass(),\nNav:maxForceForward(),\nwarmup,
        -- T50?  Assume none, negligible for this\n0) -- Brake thrust, none for this\n--
        accelDistance now has the amount of distance for which we will be accelerating\n--
        Then we need the distance we'd brake from full speed\n-- Note that for some
        nearby moons etc, it may never reach full speed though.\nlocal brakeDistance,
        brakeTime\nif not TurnBurn then \nbrakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)\nelse\nbrakeDistance,
        brakeTime = GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)\nend\nlocal
        curBrakeDistance, curBrakeTime\nif not TurnBurn then \ncurBrakeDistance, curBrakeTime
        = GetAutopilotBrakeDistanceAndTime(vec3(velocity):len())\nelse\ncurBrakeDistance,
        curBrakeTime = GetAutopilotTBBrakeDistanceAndTime(vec3(velocity):len())\nend\nlocal
        cruiseDistance = 0\nlocal cruiseTime = 0\n-- So, time is in seconds\n-- If
        cruising or braking, use real cruise/brake values\nif brakeDistance + accelDistance
        < AutopilotDistance then \n-- Add any remaining distance\ncruiseDistance =
        AutopilotDistance - (brakeDistance + accelDistance)\ncruiseTime = Kinematic.computeTravelTime(8333.0556,
        0, cruiseDistance)\nelse\nlocal accelRatio = (AutopilotDistance - brakeDistance)/accelDistance\naccelDistance
        = AutopilotDistance - brakeDistance -- Accel until we brake\naccelTime = accelTime
        * accelRatio\nend\nif AutopilotBraking then\nreturn curBrakeTime\nelseif AutopilotCruising
        then\nreturn cruiseTime + curBrakeTime\nelse -- If not cruising or braking,
        assume we'll get to max speed\nreturn accelTime + brakeTime + cruiseTime\nend\nend\nfunction
        GetAutopilotBrakeDistanceAndTime(speed)\n-- If we're in atmo, just return
        some 0's or LastMaxBrake, whatever's bigger\n-- So we don't do unnecessary
        API calls when atmo brakes don't tell us what we want\nif atmosphere() ==
        0 then\nrefreshLastMaxBrake()\nreturn Kinematic.computeDistanceAndTime(speed,
        AutopilotEndSpeed, constructMass(), 0, 0, LastMaxBrake - (AutopilotPlanetGravity
        * constructMass()))\nelse\nif LastMaxBrake and LastMaxBrake > 0 then\nreturn
        Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(),
        0, 0, LastMaxBrake - (AutopilotPlanetGravity * constructMass()))\nelse\nreturn
        0,0\nend\nend\nend\nfunction GetAutopilotTBBrakeDistanceAndTime(speed) --
        Uses thrust and a configured T50\nrefreshLastMaxBrake()\nreturn Kinematic.computeDistanceAndTime(speed,
        AutopilotEndSpeed, constructMass(), Nav:maxForceForward(), warmup, LastMaxBrake
        - (AutopilotPlanetGravity * constructMass()))\nend\nfunction GetFlightStyle()\nlocal
        flightType = Nav.axisCommandManager:getAxisCommandType(0)\nlocal flightStyle
        = \"TRAVEL\"\nif (flightType == 1) then\nflightStyle = \"CRUISE\"\nend\nif
        Autopilot then\nflightStyle = \"AUTOPILOT\"\nend\nreturn flightStyle\nend\nfunction
        round(num, numDecimalPlaces)\nlocal mult = 10^(numDecimalPlaces or 0)\nreturn
        mfloor(num * mult + 0.5) / mult\nend\nfunction tablelength(T)\nlocal count
        = 0\nfor _ in pairs(T) do count = count + 1 end\nreturn count\nend\nfunction
        BeginProfile(profileName)\nProfileTimeStart = system.getTime()\nend\nfunction
        EndProfile(profileName)\nlocal profileTime = system.getTime() - ProfileTimeStart\nProfileTimeSum
        = ProfileTimeSum + profileTime\nProfileCount = ProfileCount + 1\nif profileTime
        > ProfileTimeMax then\nProfileTimeMax = profileTime\nend\nif profileTime <
        ProfileTimeMin then\nProfileTimeMin = profileTime\nend\nend\nfunction ResetProfiles()\nProfileTimeMin
        = 9999\nProfileTimeMax = 0\nProfileCount = 0\nProfileTimeSum = 0\nend\nfunction
        ReportProfiling()\nlocal totalTime = ProfileTimeSum\nlocal averageTime = ProfileTimeSum
        / ProfileCount\nlocal min = ProfileTimeMin\nlocal max = ProfileTimeMax\nlocal
        samples = ProfileCount\nsystem.print(string.format(\"SUM: %.4f AVG: %.4f MIN:
        %.4f MAX: %.4f CNT: %d\", totalTime, averageTime, min, max, samples))\nend\nAnimating
        = false\nAnimated = false\nAddLocationsToAtlas()\nUpdateAutopilotTarget()\n--
        That was a lot of work with dirty strings and json.  Clean up\ncollectgarbage(\"collect\")\nunit.setTimer(\"apTick\",
        apTickRate)\nunit.setTimer(\"oneSecond\", 1)\nend)\n"
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()
                -- Open door and extend ramp if available
                local atmo = unit.getAtmosphereDensity()
                if door and (atmo > 0 or (atmo == 0 and core_altitude < 10000)) then
                    for _,v in pairs(door) do
                        v.activate()
                    end
                end
                if forcefield and (atmo > 0 or (atmo == 0 and core_altitude < 10000)) then
                    for _,v in pairs(forcefield) do
                        v.activate()
                    end
                end
                -- Save autovariables
                if dbHud then
                    if not ResetAutoVars then
                        for k,v in pairs(AutoVariables) do
                            dbHud.setStringValue(v,json.encode(_G[v]))
                        end
                    end
                end
                if button then
                    button.activate()
                end
        tick:
            args: ["oneSecond"]
            lua: |
                -- Timer for evaluation every 1 second
                if AutopilotTargetName ~= "None" then
                    if panelInterplanetary == nil then SetupInterplanetaryPanel() end
                    if AutopilotTargetName ~= nil then
                        planetMaxMass = GetAutopilotMaxMass() 
                        system.updateData(interplanetaryHeaderText, '{"label": "Target", "value": "' .. AutopilotTargetName .. '", "unit":""}')
                        travelTime = GetAutopilotTravelTime() -- This also sets AutopilotDistance so we don't have to calc it again
                        distance = AutopilotDistance
                        if not TurnBurn then 
                            brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(velMag)
                            maxBrakeDistance, maxBrakeTime = GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)
                        else
                            brakeDistance, brakeTime = GetAutopilotTBBrakeDistanceAndTime(velMag)
                            maxBrakeDistance, maxBrakeTime = GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)
                        end
                        system.updateData(widgetDistanceText, '{"label": "Distance", "value": "' .. getDistanceDisplayString(distance) .. '", "unit":""}')
                        system.updateData(widgetTravelTimeText, '{"label": "Travel Time", "value": "' .. FormatTimeString(travelTime) .. '", "unit":""}')
                        system.updateData(widgetCurBrakeDistanceText, '{"label": "Cur Brake Distance", "value": "' .. getDistanceDisplayString(brakeDistance) .. '", "unit":""}')
                        system.updateData(widgetCurBrakeTimeText, '{"label": "Cur Brake Time", "value": "' .. FormatTimeString(brakeTime) .. '", "unit":""}')
                        system.updateData(widgetMaxBrakeDistanceText, '{"label": "Max Brake Distance", "value": "' .. getDistanceDisplayString(maxBrakeDistance) .. '", "unit":""}')
                        system.updateData(widgetMaxBrakeTimeText, '{"label": "Max Brake Time", "value": "' .. FormatTimeString(maxBrakeTime) .. '", "unit":""}')
                        system.updateData(widgetMaxMassText, '{"label": "Maximum Mass", "value": "'..string.format("%.2f tons", (planetMaxMass/1000)).. '", "unit":""}')
                        if unit.getAtmosphereDensity() > 0 and not InAtmo then
                            system.removeDataFromWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)
                            system.removeDataFromWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)
                            system.removeDataFromWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)
                            system.removeDataFromWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)
                            system.removeDataFromWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)
                            InAtmo = true
                        elseif unit.getAtmosphereDensity() == 0 and InAtmo then
                            system.addDataToWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)
                            system.addDataToWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)
                            system.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)
                            system.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)
                            system.addDataToWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)
                            InAtmo = false
                        end
                    else
                        system.updateData(interplanetaryHeaderText, '{"label": "Target", "value": "' .. CustomTarget.name .. '", "unit":""}')
                        distance = (vec3(core.getConstructWorldPos())-CustomTarget.position):len()
                        system.updateData(widgetDistanceText, '{"label": "Distance", "value": "' .. getDistanceDisplayString(distance) .. '", "unit":""}')
                        system.removeDataFromWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)
                        system.removeDataFromWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)
                        system.removeDataFromWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)
                        system.removeDataFromWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)
                        system.removeDataFromWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)
                        system.removeDataFromWidget(widgetMaxMassText, widgetMaxMass)
                        system.removeDataFromWidget(widgetTravelTimeText, widgetTravelTime)
                    end
                else
                    HideInterplanetaryPanel()
                end
                refreshLastMaxBrake(nil, true) -- force refresh, in case we took damage
                updateDistance()
                if (radar_1 and #radar_1.getEntries() > 0) then
                    local target
                    target = radar_1.getData():find('identifiedConstructs":%[%]')
                    if hasSpaceRadar and EmergencyWarp then
                        local id,distance = radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')
                        if id ~= nil and id ~= "" then
                            if (math.floor(distance) < EmergencyWarpDistance) and notTriedEmergencyWarp then
                                emergencyWarp = true
                            end
                        end
                    end
                    if target == nil and perisPanelID == nil then
                        peris = 1
                        ToggleRadarPanel()
                    end
                    if target ~= nil and perisPanelID ~= nil then
                        ToggleRadarPanel()
                    end
                    if radarPanelID == nil then
                        ToggleRadarPanel()
                    end

                    local radarContacts = radar_1.getEntries()
                    radarMessage = string.format([[<text class="pbright txtbig txtmid" x="1770" y="330">Radar: %i contacts</text>]],#radarContacts)
                    
                    local friendlies = {}
                    for k,v in pairs(radarContacts) do
                        if radar_1.hasMatchingTransponder(v) == 1 then
                            friendlies[#friendlies+1] = v
                        end
                    end
                    if #friendlies > 0 then
                        local y = 15
                        radarMessage = string.format([[%s<text class="pbright txtbig txtmid" x="1370" y="%s">Friendlies In Range</text>]],radarMessage,y)
                        for k,v in pairs(friendlies) do 
                            y = y + 20
                            radarMessage = string.format([[%s<text class="pdim txtmid" x="1370" y="%s">%s</text>]],radarMessage,y,radar_1.getConstructName(v))
                        end
                    end
                    
                elseif radar_1 then
                    local data
                    data = radar_1.getData():find('worksInEnvironment":false')
                    if data then
                        radarMessage =  [[<text class="pbright txtbig txtmid" x="1770" y="330">Radar: Jammed</text>]]
                    else
                    radarMessage =  [[<text class="pbright txtbig txtmid" x="1770" y="330">Radar: No Contacts</text>]]
                    end
                    if radarPanelID ~= nil then
                        peris = 0
                        ToggleRadarPanel()
                    end
                end 
                if warpdrive ~= nil then
                    if emergencyWarp then
                        if json.decode(warpdrive.getData()).buttonMsg ~= "CANNOT WARP" then
                            msgText = "EMERGENCY WARP IN 5 SECONDS - PRESS ALT-J to CANCEL"
                            msgTimer = 5
                            unit.setTimer("emergencyWarpTick", 5)
                            emergencyWarp = false
                        else
                            msgText = "Emergency Warp Condition Met - Cannot Warp, will not retry\n"..(json.decode(warpdrive.getData()).errorMsg)
                            msgTick = 10
                            emergencyWarp = false
                        end
                        notTriedEmergencyWarp = false
                    end
                    if json.decode(warpdrive.getData()).buttonMsg ~= "CANNOT WARP" then
                        warpdrive.show()
                        showWarpWidget = true
                    end
                end
                -- Update odometer output string
                local newContent = {}
                local flightStyle = GetFlightStyle()
                DrawOdometer(newContent, totalDistanceTrip, totalDistanceTravelled, flightStyle, flightTime)       
                checkDamage(newContent)
                LastOdometerOutput = table.concat(newContent, "")
                collectgarbage("collect")
        tick:
            args: ["msgTick"]
            lua: |
                -- This is used to clear a message on screen after a short period of time and then stop itself
                    DisplayMessage(newContent, "empty")
                    msgText = "empty"
                    unit.stopTimer("msgTick")
                    msgTimer = 3
        tick:
            args: ["emergencyWarpTick"]
            lua: |
                msgText = "EMERGENCY WARP ACTIVATED"
                msgTimer = 5
                warpdrive.activateWarp()
                warpdrive.show()
                showWarpWidget = true
                unit.stopTimer("emergencyWarpTick")
        tick:
            args: ["animateTick"]
            lua: |
                Animated = true
                Animating = false
                simulatedX = 0
                simulatedY = 0
                unit.stopTimer("animateTick")
        tick:
            args: ["apTick"]
            lua: |
                -- Localized Functions
                local isRemote = Nav.control.isRemoteControlled
                
                yawInput2 = 0
                rollInput2 = 0
                pitchInput2 = 0
                LastApsDiff = -1
                velocity = vec3(core.getWorldVelocity())
                velMag = vec3(velocity):len()
                sys = galaxyReference[0]
                planet = sys:closestBody(core.getConstructWorldPos())
                kepPlanet = Kep(planet)
                orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)
                local deltaX = system.getMouseDeltaX()
                local deltaY = system.getMouseDeltaY()
                targetGroundAltitude = Nav:getTargetGroundAltitude()
                local TrajectoryAlignmentStrength = 0.002 -- How strongly AP tries to align your velocity vector to the target when not in orbit
                if BrakeIsOn then
                    brakeInput = 1
                else
                    brakeInput = 0
                end
                core_altitude = core.getAltitude()
                if core_altitude == 0 then
                    core_altitude = (vec3(core.getConstructWorldPos())-planet.center):len()-planet.radius
                end

                local newContent = {}
                HUDPrologue(newContent)

                if showHud then                    
                    updateHud(newContent) -- sets up Content for us
                else
                    DisplayOrbit(newContent)
                    DrawWarnings(newContent)
                end

                HUDEpilogue(newContent)

                newContent[#newContent + 1] = [[<svg width="100%" height="100%" style="position:absolute;top:0;left:0"  viewBox="0 0 2560 1440">]]
                if msgText ~= "empty" then 
                    DisplayMessage(newContent, msgText)
                end
                if isRemote() == 0 and userControlScheme == "Virtual Joystick" then
                    DrawDeadZone(newContent)
                end

                if isRemote() == 1 and screen_1 and screen_1.getMouseY() ~= -1 then
                    simulatedX = screen_1.getMouseX()*2560
                    simulatedY = screen_1.getMouseY()*1440
                    SetButtonContains()
                    DrawButtons(newContent)
                    if screen_1.getMouseState() == 1 then
                        CheckButtons()
                    end
                    newContent[#newContent + 1] = string.format([[<g transform="translate(1280 720)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]], simulatedX, simulatedY)
                elseif system.isViewLocked() == 0 then
                    if isRemote() == 1 and HoldingCtrl then
                        if not Animating then
                            simulatedX = simulatedX + deltaX
                            simulatedY = simulatedY + deltaY
                        end
                        SetButtonContains()
                        DrawButtons(newContent)

                        -- If they're remote, it's kinda weird to be 'looking' everywhere while you use the mouse
                        -- We need to add a body with a background color
                        if not Animating and not Animated then
                            local collapsedContent = table.concat(newContent, "")
                            newContent = {}
                            newContent[#newContent + 1] = "<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%' height='100%' position='absolute' top='0' left='0'><rect width='100%' height='100%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%' height='50%' style='position:absolute;top:30%;left:25%' viewbox='0 0 1920 1080'>"
                            newContent[#newContent + 1] = GalaxyMapHTML
                            newContent[#newContent + 1] = collapsedContent
                            newContent[#newContent + 1] = "</body>"
                            Animating = true
                            newContent[#newContent + 1] = [[</svg></body>]] -- Uh what.. okay...
                            unit.setTimer("animateTick",0.5)
                            local content = table.concat(newContent, "")
                            system.setScreen(content) 
                         elseif Animated then
                            local collapsedContent = table.concat(newContent, "")
                            newContent = {}
                            newContent[#newContent + 1] = "<body style='background-color:rgb(6,5,26)'><svg width='50%' height='50%' style='position:absolute;top:30%;left:25%' viewbox='0 0 1920 1080'>"
                            newContent[#newContent + 1] = GalaxyMapHTML
                            newContent[#newContent + 1] = collapsedContent
                            newContent[#newContent + 1] = "</body>"
                        end
                        
                        if not Animating then
                            newContent[#newContent + 1] = string.format([[<g transform="translate(1280 720)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]], simulatedX, simulatedY)
                        end
                    else
                        CheckButtons()
                        simulatedX = 0
                        simulatedY = 0 -- Reset after they do view things, and don't keep sending inputs while unlocked view
                        -- Except of course autopilot, which is later.
                    end
                else
                    simulatedX = simulatedX + deltaX
                    simulatedY = simulatedY + deltaY
                    distance = math.sqrt(simulatedX*simulatedX + simulatedY*simulatedY)
                    if not HoldingCtrl and isRemote() == 0 then -- Draw deadzone circle if it's navigating
                        if userControlScheme == "Virtual Joystick" then -- Virtual Joystick
                            -- Do navigation things
                            
                            if simulatedX > 0 and simulatedX > DeadZone then
                                yawInput2 = yawInput2 - (simulatedX - DeadZone) * MouseXSensitivity
                            elseif simulatedX < 0 and simulatedX < (DeadZone * -1) then
                                yawInput2 = yawInput2 - (simulatedX + DeadZone) * MouseXSensitivity
                            else
                                yawInput2 = 0
                            end
                        
                            if simulatedY > 0 and simulatedY > DeadZone then
                                pitchInput2 = pitchInput2 - (simulatedY - DeadZone) * MouseYSensitivity
                            elseif simulatedY < 0 and simulatedY < (DeadZone * -1) then
                                pitchInput2 = pitchInput2 - (simulatedY + DeadZone) * MouseYSensitivity
                            else
                                 pitchInput2 = 0
                            end
                        elseif userControlScheme == "Mouse" then -- Mouse Direct
                            simulatedX = 0
                            simulatedY = 0
                            --pitchInput2 = pitchInput2 - deltaY * mousePitchFactor
                            --yawInput2 = yawInput2 - deltaX * mouseYawFactor
                            -- So... this is weird.  
                            -- It's doing some odd things and giving us some weird values. 
                            
                            -- utils.smoothstep(progress, low, high)*2-1
                            pitchInput2 = (-utils.smoothstep(deltaY, -100, 100) + 0.5)*2*mousePitchFactor
                            yawInput2 = (-utils.smoothstep(deltaX, -100, 100) + 0.5)*2*mouseYawFactor
                        else -- Keyboard mode
                            simulatedX = 0
                            simulatedY = 0
                            -- Don't touch anything, they have it with kb only.  
                        end



                        -- Right so.  We can't detect a mouse click.  That's stupid.  
                        -- We have two options.  1. Use mouse wheel movement as a click, or 2. If you're hovered over a button and let go of Ctrl, it's a click
                        -- I think 2 is a much smoother solution.  Even if we later want to have them input some coords
                        -- We'd have to hook 0-9 in their events, and they'd have to point at the target, so it wouldn't be while this screen is open
                        
                        -- What that means is, if we get here, check our hovers.  If one of them is active, trigger the thing and deactivate the hover
                        CheckButtons()
                        
                        
                        if distance > DeadZone then -- Draw a line to the cursor from the screen center
                            -- Note that because SVG lines fucking suck, we have to do a translate and they can't use calc in their params
                            DrawCursorLine(newContent)
                        end
                    else
                        -- Ctrl is being held, draw buttons.
                        -- Brake toggle, face prograde, face retrograde (for now)
                        -- We've got some vars setup in Start for them to make this easier to work with
                        SetButtonContains()
                        DrawButtons(newContent)
                        
                    end
                    -- Cursor always on top, draw it last
                    newContent[#newContent + 1] = string.format([[<g transform="translate(1280 720)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]], simulatedX, simulatedY)
                end
                newContent[#newContent + 1] = [[</svg></body>]]
                content = table.concat(newContent, "")
                -- if content ~= LastContent then
                    --if isRemote() == 1 and screen_1 then -- Once the screens are fixed we can do this.
                    --    screen_1.setHTML(content) -- But also this is disgusting and the resolution's terrible.  We're doing something wrong.
                    --else
                    

                if not DidLogOutput then
                    system.logInfo(LastContent)
                    DidLogOutput = true
                end

                if AutoBrake and AutopilotTargetPlanetName ~= "None" and (vec3(core.getConstructWorldPos())-vec3(AutopilotTargetPlanet.center)):len() <= brakeDistance then
                    brakeInput = 1
                    if planet.name == AutopilotTargetPlanet.name and orbit.apoapsis ~= nil and orbit.eccentricity < 1 then
                            -- We're increasing eccentricity by braking, time to stop
                            brakeInput = 0
                            AutoBrake = false
                    end
                end
                if ProgradeIsOn then 
                    if velMag > MinAutopilotSpeed then -- Help with div by 0 errors and careening into terrain at low speed
                            AlignToWorldVector(vec3(velocity))
                    end
                end
                if RetrogradeIsOn then 
                    if velMag > MinAutopilotSpeed then -- Help with div by 0 errors and careening into terrain at low speed
                            AlignToWorldVector(-(vec3(velocity)))
                    end
                end
                if Autopilot and unit.getAtmosphereDensity() == 0 then
                    -- Planetary autopilot engaged, we are out of atmo, and it has a target
                    -- Do it.  
                    -- And tbh we should calc the brakeDistance live too, and of course it's also in meters
                    local brakeDistance, brakeTime
                    if not TurnBurn then
                        brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(velMag)
                    else
                        brakeDistance, brakeTime = GetAutopilotTBBrakeDistanceAndTime(velMag)
                    end
                    brakeDistance = brakeDistance 
                    brakeTime = brakeTime -- * 1.05 -- Padding?
                    -- Maybe instead of pointing at our vector, we point at our vector + how far off our velocity vector is
                    -- This is gonna be hard to get the negatives right.
                    -- If we're still in orbit, don't do anything, that velocity will suck
                    local targetCoords = AutopilotTargetCoords
                    if orbit.apoapsis == nil and velMag > 300 and AutopilotAccelerating then
                        -- Get the angle between forward and velocity
                        -- Get the magnitude for each of yaw and pitch
                        -- Consider a right triangle, with side a being distance to our target
                        -- get side b, where have the angle.  Do this once for each of yaw and pitch
                        -- The result of each of those would then be multiplied by something to make them vectors...
                        
                        
                        -- Okay another idea.
                        -- Normalize forward and velocity, then get the ratio of normvelocity:velocity
                        -- And scale forward back up by that amount.  Then take forward-velocity, the 
                        
                        
                        -- No no.
                        -- Okay so, first, when we realign, we store shipright and shipup, just for this
                        -- Get the difference between ship forward and normalized worldvel
                        -- Get the components in each of the stored shipright and shipup directions
                        -- Get the ratio of velocity to normalized velocity and scale up that component (Hey this is just velmag btw)
                        -- Add that component * shipright or shipup
                        local velVectorOffset = (vec3(AutopilotTargetCoords) - vec3(core.getConstructWorldPos())):normalize() - vec3(velocity):normalize()
                        local pitchComponent = getMagnitudeInDirection(velVectorOffset, AutopilotShipUp)
                        local yawComponent = getMagnitudeInDirection(velVectorOffset, AutopilotShipRight)
                        local leftAmount = -yawComponent * AutopilotDistance * velMag*TrajectoryAlignmentStrength
                        local downAmount = -pitchComponent * AutopilotDistance * velMag*TrajectoryAlignmentStrength
                        targetCoords = AutopilotTargetCoords + (-leftAmount * vec3(AutopilotShipRight)) + (-downAmount * vec3(AutopilotShipUp))
                    end
                    -- If we're here, sadly, we really need to calc the distance every update (or tick)
                    AutopilotDistance = (vec3(targetCoords) - vec3(core.getConstructWorldPos())):len()
                    system.updateData(widgetDistanceText, '{"label": "Distance", "value": "' .. getDistanceDisplayString(AutopilotDistance) .. '", "unit":""}')
                    local aligned = true  -- It shouldn't be used if the following condition isn't met, but just in case
                        
                    local projectedAltitude = (AutopilotTargetPlanet.center - (vec3(core.getConstructWorldPos()) + (vec3(velocity):normalize() * AutopilotDistance))):len() - AutopilotTargetPlanet.radius
                    system.updateData(widgetTrajectoryAltitudeText, '{"label": "Projected Altitude", "value": "' .. getDistanceDisplayString(projectedAltitude) .. '", "unit":""}')

                    if not AutopilotCruising and not AutopilotBraking then
                        aligned = AlignToWorldVector((targetCoords-vec3(core.getConstructWorldPos())):normalize())
                    elseif TurnBurn then
                        aligned = AlignToWorldVector(-vec3(velocity):normalize())
                    end
                    if AutopilotAccelerating then
                        if not aligned then
                            AutopilotStatus = "Adjusting Trajectory"
                        else
                            AutopilotStatus = "Accelerating"
                        end
                        
                        if vec3(core.getVelocity()):len() >= MaxGameVelocity then -- This is 29999 kph
                            AutopilotAccelerating = false
                            AutopilotStatus = "Cruising"
                            AutopilotCruising = true
                            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)
                        end
                        -- Check if accel needs to stop for braking
                        if AutopilotDistance <= brakeDistance then
                            AutopilotAccelerating = false
                            AutopilotStatus = "Braking"
                            AutopilotBraking = true
                            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)
                        end
                    elseif AutopilotBraking then
                        BrakeIsOn = true
                        brakeInput = 1
                        if TurnBurn then
                            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100) -- This stays 100 to not mess up our calculations
                        end
                        -- Check if an orbit has been established and cut brakes and disable autopilot if so
                        
                        -- We'll try <0.9 instead of <1 so that we don't end up in a barely-orbit where touching the controls will make it an escape orbit
                        -- Though we could probably keep going until it starts getting more eccentric, so we'd maybe have a circular orbit
                        
                        if orbit.periapsis ~= nil and orbit.eccentricity < 1 then
                            AutopilotStatus = "Circularizing"
                            -- Keep going until the apoapsis and periapsis start getting further apart
                            -- Rather than: orbit.periapsis ~= nil and orbit.periapsis.altitude < ((vec3(planet.center) - vec3(core.getConstructWorldPos())):len() - planet.radius)-1000
                            --local apsDiff = math.abs(orbit.apoapsis.altitude - orbit.periapsis.altitude)
                            --if LastApsDiff ~= -1 and apsDiff > LastApsDiff then 
                            if orbit.eccentricity > LastEccentricity or (orbit.apoapsis.altitude < AutopilotTargetOrbit and orbit.periapsis.altitude < AutopilotTargetOrbit) then
                                --LastApsDiff = -1
                                BrakeIsOn = false
                                AutopilotBraking = false
                                Autopilot = false
                                AutopilotStatus = "Aligning" -- Disable autopilot and reset
                                -- TODO: This is being added to newContent *after* we already drew the screen, so it'll never get displayed
                                DisplayMessage(newContent, "Autopilot completed, orbit established")
                                brakeInput = 0
                                Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)
                            end
                            LastApsDiff = apsDiff
                        end
                    elseif AutopilotCruising then
                        if AutopilotDistance <= brakeDistance then
                            AutopilotAccelerating = false
                            AutopilotStatus = "Braking"
                            AutopilotBraking = true
                        end
                    else
                        -- It's engaged but hasn't started accelerating yet.
                        if aligned then
                                -- Re-align to 200km from our aligned right                    
                                if not AutopilotRealigned then -- Removed radius from this because it makes our readouts look inaccurate?
                                    AutopilotTargetCoords = vec3(AutopilotTargetPlanet.center) + ((AutopilotTargetOrbit + AutopilotTargetPlanet.radius) * vec3(core.getConstructWorldOrientationRight()))
                                    AutopilotRealigned = true
                                    AutopilotShipUp = core.getConstructWorldOrientationUp()
                                    AutopilotShipRight = core.getConstructWorldOrientationRight()
                                elseif aligned then
                                    AutopilotAccelerating = true
                                    AutopilotStatus = "Accelerating"
                                    -- Set throttle to max
                                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, AutopilotInterplanetaryThrottle)
                            end
                        end
                        -- If it's not aligned yet, don't try to burn yet.
                    end
                end
                if FollowMode then
                    -- User is assumed to be outside the construct
                    autoRoll = true -- Let Nav handle that while we're here
                    local targetPitch = 0
                    -- Keep brake engaged at all times unless: 
                        -- Ship is aligned with the target on yaw (roll and pitch are locked to 0)
                        -- and ship's speed is below like 5-10m/s
                    local pos = vec3(core.getConstructWorldPos()) + vec3(unit.getMasterPlayerRelativePosition()) -- Is this related to core forward or nah?
                    local distancePos = (pos-vec3(core.getConstructWorldPos()))
                    --local distance = distancePos:len()
                    -- Distance needs to be calculated using only construct forward and right
                    local distanceForward = vec3(distancePos):project_on(vec3(core.getConstructWorldOrientationForward())):len()
                    local distanceRight = vec3(distancePos):project_on(vec3(core.getConstructWorldOrientationRight())):len()
                    --local distanceDown = vec3(distancePos):project_on(-vec3(core.getConstructWorldOrientationRight())):len()
                    local distance = math.sqrt(distanceForward*distanceForward+distanceRight*distanceRight)
                    AlignToWorldVector(distancePos:normalize())
                    local targetDistance = 40
                    --local onShip = false
                    --if distanceDown < 1 then 
                    --    onShip = true
                    --end
                    local nearby = (distance < targetDistance)
                    local maxSpeed = 100 -- Over 300kph max, but, it scales down as it approaches
                    if onShip then
                        maxSpeed = 300
                    end
                    local targetSpeed = utils.clamp((distance-targetDistance)/2,10,maxSpeed)
                    pitchInput2 = 0
                    local aligned = (math.abs(yawInput2) < 0.1)
                    if (aligned and velMag < targetSpeed and not nearby) then -- or (not BrakeIsOn and onShip) then
                        --if not onShip then -- Don't mess with brake if they're on ship
                            BrakeIsOn = false
                        --end
                        targetPitch = -10
                    else
                        --if not onShip then
                            BrakeIsOn = true
                        --end
                        targetPitch = 0
                    end
                    local constrF = vec3(core.getConstructWorldOrientationForward())
                    local constrR = vec3(core.getConstructWorldOrientationRight())
                    local worldV = vec3(core.getWorldVertical())
                    local pitch = getPitch(worldV, constrF, constrR)
                    local autoPitchThreshold = 1.0
                    -- Copied from autoroll let's hope this is how a PID works... 
                    if math.abs(targetPitch - pitch) > autoPitchThreshold then
                        if (pitchPID == nil) then
                            pitchPID = pid.new(2 * 0.01, 0, 2 * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        pitchPID:inject(targetPitch - pitch)
                        local autoPitchInput = pitchPID:get()

                        pitchInput2 = autoPitchInput
                    end
                end
                local up = vec3(core.getWorldVertical()) * -1
                if AltitudeHold or BrakeLanding or Reentry or VectorToTarget then
                    autoRoll = true
                    if Reentry then
                        Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.longitudinal, ReentrySpeed)
                        Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.vertical, 0)
                        Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.lateral, 0)
                        --system.print("Actual: "..Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal).." Target: "..ReentrySpeed)  
                        if Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == ReentrySpeed then -- This thing is dumb.
                            Reentry = false
                        end
                    end
                    -- HoldAltitude is the alt we want to hold at
                    local altitude = core_altitude
                    -- Dampen this.
                    local altDiff = HoldAltitude - altitude
                    -- This may be better to smooth evenly regardless of HoldAltitude.  Let's say, 2km scaling?  Should be very smooth for atmo
                    -- Even better if we smooth based on their velocity
                    local minmax = 500 + velMag
                    local targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5)*2*MaxPitch 
                    if not AltitudeHold then
                        targetPitch = 0
                    end
                    -- The clamp should now be redundant
                    --local targetPitch = utils.clamp(altDiff,-20,20) -- Clamp to reasonable values
                    -- Align it prograde but keep whatever pitch inputs they gave us before, and ignore pitch input from alignment.
                    -- So, you know, just yaw.
                    local oldInput = pitchInput2
                    if velMag > MinAutopilotSpeed then
                        AlignToWorldVector(vec3(velocity))
                    end
                    if VectorToTarget and CustomTarget ~= nil and AutopilotTargetIndex > 0 then
                        local targetVec = CustomTarget.position-vec3(core.getConstructWorldPos())
                        -- We're overriding pitch and roll so, this will just set yaw, we can do this directly
                        AlignToWorldVector(targetVec)

                        
                        local distanceToTarget = targetVec:len() - targetVec:project_on(up):len() -- Probably not strictly accurate with curvature but it should work
                        -- Well, maybe not.  Really we have a triangle.  Of course.  
                        -- We know C, our distance to target.  We know the height we'll be above the target (should be the same as our current height)
                        -- We just don't know the last leg
                        -- a2 + b2 = c2.  c2 - b2 = a2
                        local targetAltitude = (CustomTarget.position-planet.center-planet.radius):len()
                        --local distanceToTarget = math.sqrt(targetVec:len()^2-(HoldAltitude-targetAltitude)^2)
                        local maxBrake = json.decode(unit.getData()).maxBrake
                        local vSpd = (velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z)
                        local hSpd = velocity:len() - math.abs(vSpd)
                        local airFriction = vec3(core.getWorldAirFrictionAcceleration()) -- Maybe includes lift?
                        if maxBrake ~= nil then
                            LastMaxBrake = maxBrake
                            brakeDistance, brakeTime = Kinematic.computeDistanceAndTime(hSpd, 0, core.getConstructMass(), 0, 0, maxBrake+(airFriction:len()-airFriction:project_on(up):len())*core.getConstructMass())
                        else
                            brakeDistance, brakeTime = Kinematic.computeDistanceAndTime(hSpd, 0, core.getConstructMass(), 0, 0, LastMaxBrake+vec3(core.getWorldAirFrictionAcceleration()):len()*core.getConstructMass())
                        end
                        --system.print("Distance " .. distanceToTarget .. " brake " .. brakeDistance .. " vel " .. velocity:len() .. " vspd " .. vSpd)
                        StrongBrakes = ( ((planet:getGravity(planet.center + (vec3(0,0,1)*planet.radius)):len()) * core.getConstructMass()) <  LastMaxBrake)
                        if distanceToTarget <= brakeDistance then
                            VectorStatus = "Finalizing Approach"
                            if Nav.axisCommandManager:getAxisCommandType(0) == 1 then
                                Nav.control.cancelCurrentControlMasterMode()
                            end
                            if AltitudeHold then
                                ToggleAltitudeHold() -- Don't need this anymore
                                VectorToTarget = true -- But keep this part on... 
                            end
                            if StrongBrakes then
                                BrakeIsOn = true
                            else
                                VectorToTarget = false -- We're done here.  Toggle on the landing routine for coast-landing
                                BrakeLanding = true
                            end
                            
                        elseif not AutoTakeoff then
                            BrakeIsOn = false
                        end
                        if LastTargetDistance ~= nil and distanceToTarget > LastTargetDistance and not AltitudeHold and not AutoTakeoff then
                            BrakeLanding = true
                            VectorToTarget = false
                        end
                        LastTargetDistance = distanceToTarget
                    end
                    pitchInput2 = oldInput
                    local groundDistance = -1
                    if BrakeLanding then
                        targetPitch = 0
                        if Nav.axisCommandManager:getAxisCommandType(0) == 1 then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        Nav.axisCommandManager:setTargetGroundAltitude(500)
                        Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(500)
                        if vBooster then
                            groundDistance = vBooster.distance()
                        elseif hover then
                            groundDistance = hover.distance()
                        end
                        local vSpd = (velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z)
                        if groundDistance > -1 then
                            autoRoll = autoRollPreference
                            if velMag < 1 then
                                BrakeLanding = false
                                AltitudeHold = false
                                gearExtended = true
                                Nav.control.extendLandingGears()
                                Nav.axisCommandManager:setTargetGroundAltitude(0)
                                upAmount = 0
                                BrakeIsOn = true
                            else
                                BrakeIsOn = true
                            end
                        elseif StrongBrakes and (velocity:normalize():dot(-up) < 0.99) then
                            BrakeIsOn = true
                        elseif vSpd < -brakeLandingRate then
                            BrakeIsOn = true
                        else
                            BrakeIsOn = false
                        end
                    end
                    if AutoTakeoff then
                        if targetPitch < 20 then
                            AutoTakeoff = false -- No longer in ascent
                            if Nav.axisCommandManager:getAxisCommandType(0) == 0 then
                                Nav.control.cancelCurrentControlMasterMode()
                            end
                        end
                    end
                    local constrF = vec3(core.getConstructWorldOrientationForward())
                    local constrR = vec3(core.getConstructWorldOrientationRight())
                    local worldV = vec3(core.getWorldVertical())
                    local pitch = getPitch(worldV, constrF, constrR)
                    local autoPitchThreshold = 0.1
                    -- Copied from autoroll let's hope this is how a PID works... 
                    if math.abs(targetPitch - pitch) > autoPitchThreshold then
                        if (pitchPID == nil) then -- Changed from 2 to 8 to tighten it up around the target
                            pitchPID = pid.new(8 * 0.01, 0, 8 * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        pitchPID:inject(targetPitch - pitch)
                        local autoPitchInput = pitchPID:get()
                        pitchInput2 = pitchInput2 + autoPitchInput
                    end
                end
                LastEccentricity = orbit.eccentricity
    system:
        start:
            lua: |
                toggleView = true
                function DisplayMessage(newContent, displayText)
                    if displayText ~= "empty" then
                        newContent[#newContent + 1] = [[<text class="msg" x="50%%" y="310" >]]
                        for str in string.gmatch(displayText, "([^\n]+)") do
                            newContent[#newContent + 1] = string.format([[<tspan x="50%%" dy="35">%s</tspan>]], str)
                        end
                        newContent[#newContent + 1] = [[</text>]]
                    end            
                    if msgTimer ~= 0 then 
                        unit.setTimer("msgTick", msgTimer)
                        msgTimer = 0
                    end     
                end                
                
                function updateDistance()
                    local curTime = system.getTime()
                    local velocity = vec3(core.getWorldVelocity())
                    local spd = vec3(velocity):len()
                    local elapsedTime = curTime - lastTravelTime
                    if(spd > 1.38889) then
                        spd = spd / 1000
                        local newDistance = spd * (curTime - lastTravelTime)
                        totalDistanceTravelled = totalDistanceTravelled + newDistance
                        totalDistanceTrip = totalDistanceTrip + newDistance
                    end
                    flightTime = flightTime + elapsedTime
                    totalFlightTime = totalFlightTime + elapsedTime
                    lastTravelTime = curTime
                end
                function updateMass()
                    local totMass = 0
                    for k in pairs(elementsID) do
                        totMass = totMass + core.getElementMassById(elementsID[k])
                    end
                    return totMass
                end
                
                
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu


                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + pitchInput2 + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + rollInput2 + system.getControlDeviceYawInput()
                local finalYawInput = (yawInput + yawInput2) - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    if upAmount ~= 0 or BrakeLanding then
                        Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                    else
                        Nav:setEngineForceCommand(verticalStrafeEngineTags, vec3(), keepCollinearity)
                    end
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')
                -- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition
                speed = vec3(core.getVelocity()):len() 
                cc_speed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)                
                if Nav.axisCommandManager:getAxisCommandType(0) == 1 and (speed * 3.6 > cc_speed) then 
                        unit.setEngineThrust('rocket_engine',0)                
                elseif(isboosting) then 
                        unit.setEngineThrust('rocket_engine',1)                
                end
        update:
            lua: |
                if not SetupComplete then
                    local _, result = coroutine.resume(beginSetup)
                    if result then
                        SetupComplete = true
                    end
                else
                    Nav:update()
                    if not Animating and content ~= LastContent then
                        system.setScreen(content) 
                    end
                    LastContent = content
                end

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    VectorToTarget = false
                    if (vBooster or hover) and (unit.getAtmosphereDensity() > 0 or core_altitude < ReentryAltitude) then
                        StrongBrakes = ( ((planet:getGravity(planet.center + (vec3(0,0,1)*planet.radius)):len()) * core.getConstructMass()) <  LastMaxBrake)
                        if not StrongBrakes and velMag > MinAutopilotSpeed then
                            msgText = "WARNING: Insufficient Brakes - Attempting coast landing, beware obstacles"
                        end
                        if Nav.axisCommandManager:getAxisCommandType(0) == 1 then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        Reentry = false
                        AutoTakeoff = false
                        AltitudeHold = false
                        BrakeLanding = true
                        autoRoll = true
                        gearExtended = false -- Don't actually do it
                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)                           
                        --Nav.control.extendLandingGears()
                        --Nav.axisCommandManager:setTargetGroundAltitude(0)
                    elseif ReentryMode and unit.getAtmosphereDensity() <= 0 and unit.getClosestPlanetInfluence() > 0 and core_altitude > ReentryAltitude then
                        Reentry = true
                        gearExtended = false -- Don't actually do it
                        if Nav.axisCommandManager:getAxisCommandType(0) ~= controlMasterModeId.cruise then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        AltitudeHold = true
                        autoroll = true
                        BrakeIsOn = false
                        HoldAltitude = ReentryAltitude
                        msgText = "Beginning Re-entry.  Target speed: "..ReentrySpeed.." Target Altitude: "..ReentryAltitude
                    else
                        Nav.control.extendLandingGears()
                        Nav.axisCommandManager:setTargetGroundAltitude(0)
                    end
                else
                    Nav.control.retractLandingGears()
                    Nav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1
        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                upAmount = upAmount + 1
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                upAmount = upAmount - 1
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                upAmount = upAmount - 1
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                upAmount = upAmount + 1
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: |
                OldButtonMod = HoldAltitudeButtonModifier
                if AltitudeHold then
                    HoldAltitude = HoldAltitude + HoldAltitudeButtonModifier
                else
                    Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)
                end

        actionLoop:
            args: [groundaltitudeup]
            lua: |
                if AltitudeHold then
                    HoldAltitude = HoldAltitude + HoldAltitudeButtonModifier
                    HoldAltitudeButtonModifier = HoldAltitudeButtonModifier * 1.05
                else
                    Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)
                end
        
        actionStop:
            args: [groundaltitudeup]
            lua: |
                if AltitudeHold then
                    HoldAltitudeButtonModifier = OldButtonMod
                end

        actionStart:
            args: [groundaltitudedown]
            lua: |
                OldButtonMod = HoldAltitudeButtonModifier
                if AltitudeHold then
                    HoldAltitude = HoldAltitude - HoldAltitudeButtonModifier
                else
                    Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)
                end

        actionLoop:
            args: [groundaltitudedown]
            lua: |
                if AltitudeHold then
                    HoldAltitude = HoldAltitude - HoldAltitudeButtonModifier
                    HoldAltitudeButtonModifier = HoldAltitudeButtonModifier * 1.05
                else
                    Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)
                end
        actionStop:
            args: [groundaltitudedown]
            lua: |
                if AltitudeHold then
                    HoldAltitudeButtonModifier = OldButtonMod
                end
        actionStart:
            args: [option1]
            lua: |
                IncrementAutopilotTargetIndex()
                toggleView = false
        actionStart:
            args: [option2]
            lua: |
                DecrementAutopilotTargetIndex()
                toggleView = false
        actionStart:
            args: [option3]
            lua: |
                if hideHudOnToggleWidgets then
                    if showHud then 
                        showHud = false
                    else 
                        showHud = true
                    end
                end
                toggleView = false
                ToggleWidgets()
        actionStart:
            args: [option4]
            lua: |
                --if unit.getAtmosphereDensity() > 0 then 
                --    msgText "Clear atmosphere before engaging autopilot"
                --else
                 AutopilotToggle()
                 toggleView = false
                --end
        actionStart:
            args: [option5]
            lua: |
                ToggleTurnBurn()
                toggleView = false
        actionStart:
            args: [option6]
            lua: |
                ToggleAltitudeHold()
                toggleView = false
        actionStart:
            args: [option7]
            lua: |
                saveVariables()
                toggleView = false
        actionStart:
            args: [option8]
            lua: |
                toggleFollowMode()
                toggleView = false
        actionStart:
            args: [option9]
            lua: |
                if gyro ~= nil then
                    gyro.toggle()
                    GyroIsOn = gyro.getState() == 1
                end
                toggleView = false
        actionStart:
            args: [lshift]
            lua: |
                if system.isViewLocked() == 1 then
                    HoldingCtrl = true
                    PrevViewLock = system.isViewLocked()
                    system.lockView(1)
                elseif Nav.control.isRemoteControlled() == 1 and ShiftShowsRemoteButtons then
                    HoldingCtrl = true
                    Animated = false
                    Animating = false
                end
        actionStop: 
            args: [lshift]
            lua: |
                if system.isViewLocked() == 1 then
                    HoldingCtrl = false
                    simulatedX = 0
                    simulatedY = 0 -- Reset for steering purposes
                    system.lockView(PrevViewLock)
                elseif Nav.control.isRemoteControlled() == 1 and ShiftShowsRemoteButtons then
                    HoldingCtrl = false
                    Animated = false
                    Animating = false
                end
        actionStart:
            args: [brake]
            lua: |
                if brakeToggle then 
                    BrakeToggle()
                elseif not BrakeIsOn then
                    BrakeToggle() -- Trigger the cancellations
                else
                    BrakeIsOn = true -- Should never happen
                end
        actionStop:
            args: [brake]
            lua: |
                if not brakeToggle then 
                    if BrakeIsOn then
                        BrakeToggle()
                    else
                        BrakeIsOn = false -- Should never happen
                    end
                end
        actionStart:
            args: [lalt]
            lua: |
                if Nav.control.isRemoteControlled() == 0 and not freeLookToggle and userControlScheme == "Keyboard" then
                    system.lockView(1)
                end
        actionStop:
            args: [lalt]
            lua: |
                if Nav.control.isRemoteControlled() == 0 and freeLookToggle then
                    if toggleView then
                        if system.isViewLocked() == 1 then
                            system.lockView(0)
                        else
                            system.lockView(1)
                        end
                    else
                        toggleView = true
                    end
                elseif Nav.control.isRemoteControlled() == 0 and not freeLookToggle and userControlScheme == "Keyboard" then
                    system.lockView(0)
                end

        actionStart:
            args: [booster]
            lua: |
                --Nav:toggleBoosters()
                -- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition
                isboosting = not isboosting
                if(isboosting) then unit.setEngineThrust('rocket_engine',1)
                else unit.setEngineThrust('rocket_engine',0)
                end
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: |
                if not HoldingCtrl then 
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, speedChangeLarge)
                else
                    IncrementAutopilotTargetIndex()
                end
        actionLoop:
            args: [speedup]
            lua: |
                if not HoldingCtrl then 
                    Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, speedChangeSmall)
                end
        actionStart:
            args: [speeddown]
            lua: |
                if not HoldingCtrl then 
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -speedChangeLarge)
                else
                    DecrementAutopilotTargetIndex()
                end
        actionLoop:
            args: [speeddown]
            lua: |
                if not HoldingCtrl then 
                    Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -speedChangeSmall)
                end
        actionStart:
            args: [antigravity]
            lua: |
                if antigrav ~= nil then 
                    antigrav.toggle() 
                end
        actionStart:
            args: [warp]
            lua: |
                if warpdrive ~= nil then 
                    if not emergencyWarp then 
                        if showWarpWidget then 
                            warpdrive.hide()
                            showWarpWidget = false
                        else
                            warpdrive.show()
                            showWarpWidget = true
                        end
                        if json.decode(warpdrive.getData()).buttonMsg == "CANNOT WARP" then
                            msgText = json.decode(warpdrive.getData()).errorMsg
                        else
                            warpdrive.activateWarp() 
                            warpdrive.show()
                            showWarpWidget = true
                        end
                    else
                        unit.stopTimer("emergencyWarpTick")
                        emergencyWarp = false
                        msgText = "Emergency Warp Cancelled"
                    end   
                end

